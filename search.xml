<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS之我的知识盲区系列（一）</title>
    <url>/2020/04/08/CSS%E4%B9%8B%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>记录关于CSS的遗忘知识点。</p>
<a id="more"></a>

<h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>转自阮一峰老师: <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>采用Flex布局的元素，称为Flex容器，它的所有子元素自动称为容器成员，称为flex项目（flex item）</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png" alt="img"></p>
<h4 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h4><p> flex-direction     定义主轴的方向，即项目排列的方向。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">row</span>：默认值，主轴为水平方向，从左到右</span><br><span class="line"><span class="keyword">row</span>-<span class="keyword">reverse</span>:主轴为水平方向，从右到左</span><br><span class="line"><span class="keyword">column</span>:主轴为垂直方向，从上到下</span><br><span class="line"><span class="keyword">column</span>-<span class="keyword">reverse</span>：主轴为垂直方向，从下到上</span><br></pre></td></tr></table></figure>
<p> flex-wrap   定义换行</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">nowrap: 默认值，不换行</span><br><span class="line"><span class="built_in">wrap</span>：换行，第一行在上方</span><br><span class="line"><span class="built_in">wrap</span>-<span class="built_in">reverse</span>：换行，第一行在下方</span><br></pre></td></tr></table></figure>
<p> flex-flow  是flex-direction和flex-wrap的简写形式</p>
<p>   默认row nowrap；</p>
<p> justify-content  定义项目在主轴上的对齐方式</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">flex-start  对齐开始的一端</span><br><span class="line">flex-<span class="keyword">end</span>   对齐结束的一端</span><br><span class="line">center   居中对齐</span><br><span class="line"><span class="literal">space</span>-<span class="keyword">between</span>  两端对齐</span><br><span class="line"><span class="literal">space</span>-<span class="keyword">around</span>   每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure>
<p> align-items  定义项目在交叉轴上如何对齐</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">flex-<span class="built_in">start</span></span><br><span class="line">flex-<span class="keyword">end</span></span><br><span class="line">center</span><br><span class="line">stretch默认值：如果<span class="keyword">item</span>未设置交叉轴上的高度/宽度，将沾满整个容器的高/宽</span><br><span class="line">baseline：项目的第一行文字的基线对齐</span><br></pre></td></tr></table></figure>
<p> align-content  定义多根轴线的对齐方式</p>
<p>  <img src="https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png" alt="img"></p>
<h4 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">order</span> 定义项目的排列顺序  数值越小，排列越靠前</span><br><span class="line"><span class="attribute">flex-grow</span>  定义项目的放大比例，默认为0，如果所有项目都有此属性，则会按比例放大</span><br><span class="line"><span class="attribute">flex-shrink</span> 定义项目的缩小比例，默认为1.</span><br><span class="line">如果所有项目比例为1，一个为0；那么空间不足时，为0的不会缩小，其他的会缩小。</span><br><span class="line"><span class="attribute">flex-basis</span>  定义在分配多余空间之前，项目占据的主轴空间，默认是<span class="attribute">auto</span>，即项目本来大小</span><br><span class="line"><span class="attribute">flex</span>  是<span class="attribute">flex-grow</span>，<span class="attribute">flex-shrink</span>，<span class="attribute">flex-basis</span>的简写，默认是0 1 <span class="attribute">auto</span></span><br><span class="line"><span class="attribute">align-self</span>  允许单个项目有与其他项目不一样的对齐方式，可覆盖alignitems属性</span><br></pre></td></tr></table></figure>

<h2 id="隐藏滚动条"><a href="#隐藏滚动条" class="headerlink" title="隐藏滚动条"></a>隐藏滚动条</h2><p>原本的内容超出盒子的大小，给盒子设置overflow-y:scroll;              overflow-x:hidden;<br>可以在盒子外面再包裹一个div盒子，给这个盒子设置同样的宽高，然后设置overflow:hidden即可。这样子盒子的滚动条被隐藏，但是滚动条依然还在的奥。</p>
<p> overflow属性    overflow-x   overflow-y</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">visible：默认值，超出的内容不会被修剪，会出现在元素框外</span><br><span class="line">hidden：超出的部分会被修剪</span><br><span class="line">scroll：内容会被修剪，但是在宽的旁边会生成一个滚动条</span><br><span class="line"><span class="attribute">auto</span>：内容如果被修剪，就会出现滚动条</span><br><span class="line"><span class="attribute">inherit</span>：继承父元素属性值</span><br></pre></td></tr></table></figure>


<h2 id="borderimage属性"><a href="#borderimage属性" class="headerlink" title="borderimage属性"></a>borderimage属性</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">border</span>-<span class="built_in">image</span>(URL)</span><br><span class="line">  <span class="built_in">border</span>-<span class="built_in">image</span>-slice:裁剪位置 ，单位px</span><br><span class="line">  <span class="built_in">border</span>-<span class="built_in">image</span>-repeat:重复性</span><br><span class="line">    stretch  默认值，拉伸</span><br><span class="line">    <span class="built_in">round</span>  平铺</span><br><span class="line">    none不重复</span><br><span class="line">    repeat  重复</span><br></pre></td></tr></table></figure>
<h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>  定义动画<br>  <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">@keyframes</span> name&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">animation</span>:name <span class="number">2s</span> linear infinite;</span><br></pre></td></tr></table></figure></p>
<h2 id="3d效果"><a href="#3d效果" class="headerlink" title="3d效果"></a>3d效果</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">需要为元素添加 </span><br><span class="line"><span class="attribute">transform-style</span>:preserve-<span class="number">3</span>d;</span><br><span class="line">父元素添加</span><br><span class="line"><span class="attribute">perspective</span>:<span class="number">2000px</span>;</span><br></pre></td></tr></table></figure>
<h2 id="重排-和-重绘"><a href="#重排-和-重绘" class="headerlink" title="重排 和 重绘"></a>重排 和 重绘</h2><p> <strong>重排</strong><br>   DOM的变化影响到元素的属性变化，例如宽高，浏览器重新计算元素的几何属性，其他元素的几何属性也会受到影响，浏览器需要重新构建渲染树<br> <strong>重绘</strong><br>   浏览器将受到影响的部分重新绘制在屏幕上。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识Ajax</title>
    <url>/2020/04/10/AJAX%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结Ajax的用法，以及相关的概念。</p>
<a id="more"></a>

<h3 id="一、Ajax的由来"><a href="#一、Ajax的由来" class="headerlink" title="一、Ajax的由来"></a>一、Ajax的由来</h3><p>在了解Ajax由来之前，先从一个小案例说起。上网浏览的页面都是浏览器先服务端发起请求，服务端得到请求之后，读取并处理数据返回给客户端并且呈现出来。一个请求对应一个页面，传统的页面交互功能，也是通过请求回执的信息去更新一个页面。</p>
<p>如果在庞大的页面中，只需要更新一小块内容，但是每次都必须更新一个页面，是不是过于浪费呢？<br>以及，在请求过程中，页面的等待时间过长也会带来不好的体验，因此想要进行局部更新，并且不会产生等待页面，即不会阻塞后面代码的运行，就产生了Ajax，通过<strong>异步</strong>方式发出请求，并实现页面的<strong>局部更新</strong>。也就是Ajax的由来以及最主要的用法。</p>
<p>Ajax的核心是XMLHttpRequest（简称XHR），XHR为浏览器<strong>发送请求</strong>和<strong>解析服务器响应</strong>提供了流畅的接口。现在的浏览器基本都支持原生的XHR对象。</p>
<h3 id="二、原生js实现ajax"><a href="#二、原生js实现ajax" class="headerlink" title="二、原生js实现ajax"></a>二、原生js实现ajax</h3><p>总结来自 W3school <a href="https://www.w3school.com.cn/ajax/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/ajax/index.asp</a></p>
<p><strong>创建XMLHttpRequest对象</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (window.XMLHttpRequest)&#123;</span><br><span class="line">    <span class="comment">//IE7+,Firefox,Chrome,Opera,Safari</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// IE6,IE5浏览器执行代码</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> <span class="type">ActiveXObject</span>(<span class="string">"Microsoft.XMLHTTP"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向服务器发送请求</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">xmlhtttp.<span class="keyword">open</span>(<span class="keyword">method</span>, url , async); </span><br><span class="line"><span class="comment">//method：请求的类型；GET 或 POST</span></span><br><span class="line"><span class="comment">//method：请求的类型；GET 或 POST</span></span><br><span class="line"><span class="comment">//async：true（异步）或 false（同步）</span></span><br><span class="line">xmlhttp.send(<span class="built_in">string</span>)  <span class="comment">//string仅用于post请求</span></span><br><span class="line"></span><br><span class="line">get请求：</span><br><span class="line">xmlhttp.<span class="keyword">open</span>(<span class="string">"GET"</span>, <span class="string">"/try/ajax/demo_get.php?t="</span> + <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>random<span class="literal">()</span>, <span class="literal">true</span>);</span><br><span class="line">xmlhttp.send<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">post请求：</span><br><span class="line">xmlhttp.<span class="keyword">open</span>(<span class="string">"POST"</span>,<span class="string">"/try/ajax/demo_post2.php"</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//使用 setRequestHeader() 来添加 HTTP 头;</span></span><br><span class="line">xmlhttp.set<span class="constructor">RequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>)</span>;</span><br><span class="line">xmlhttp.send(<span class="string">"fname=Henry&amp;lname=Ford"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>服务器响应</strong><br>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>responseText</td>
<td>获得字符串式的响应数据</td>
</tr>
<tr>
<td>responseXML</td>
<td>获得XML形式的响应数据</td>
</tr>
</tbody></table>
<p>responseText 属性</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">document.getElementById(<span class="string">"myDiv"</span>).<span class="attribute">innerHTML</span>=xmlhttp.responseText;</span><br></pre></td></tr></table></figure>
<p>responseXML 属性</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">xmlDoc</span>=xmlhttp.responseXML;</span><br><span class="line"><span class="attribute">txt</span>=<span class="string">""</span>;</span><br><span class="line"><span class="attribute">x</span>=xmlDoc.getElementsByTagName("ARTIST");</span><br><span class="line"><span class="keyword">for</span> (<span class="attribute">i</span>=0;i&lt;x.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">txt</span>=txt + x[i].childNodes[0].nodeValue + <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(<span class="string">"myDiv"</span>).<span class="attribute">innerHTML</span>=txt;</span><br></pre></td></tr></table></figure>
<p><strong>onreadystatechange 事件</strong><br>当请求被发送到服务器时，我们需要执行一些基于响应的任务。<br>每当 readyState 改变时，就会触发 onreadystatechange 事件。</p>
<table>
    <tr>
        <th> 属性 </th>
        <th> 描述 </th>
    </tr>
    <tr>
        <td> onreadystatechange </td>
        <td> 存储函数或函数名，每当readyState变化shift，就会触发函数 </td>
    </tr>
     <tr>
        <td> readyState </td>
        <td> 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。
            <ul>
                <li> 0: 请求未初始化 </li>
                <li> 1: 服务器连接已建立 </li>
                <li> 2: 请求已接收 </li>
                <li> 3: 请求处理中 </li>
                <li> 4: 请求已完成，且响应已就绪 </li>
            </ul>
         </td>
    </tr>
    <tr>
        <td> status </td>
        <td> 200: "OK" <br>
            404: 未找到页面 </td>
    </tr>
</table>
在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。
当 readyState 等于 4 且状态为 200 时，表示响应已就绪：
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">xmlhttp.<span class="attribute">onreadystatechange</span>=function()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.<span class="attribute">readyState</span>==4 &amp;&amp; xmlhttp.<span class="attribute">status</span>==200)</span><br><span class="line">    &#123;</span><br><span class="line">        document.getElementById(<span class="string">"myDiv"</span>).<span class="attribute">innerHTML</span>=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、封装一个ajax吧"><a href="#三、封装一个ajax吧" class="headerlink" title="三、封装一个ajax吧"></a>三、封装一个ajax吧</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> obj2str(data)&#123;</span><br><span class="line">    data = data<span class="operator"> || </span>&#123;&#125;;<span class="comment">// 如果没有传参, 为了添加随机因子,必须自己创建一个对象</span></span><br><span class="line">    data.t = <span class="keyword">new</span> <span class="constructor">Date()</span>.get<span class="constructor">Time()</span>;</span><br><span class="line">    var res = <span class="literal">[]</span>;</span><br><span class="line">    for (var key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        res.push(encode<span class="constructor">URLComponent(<span class="params">key</span>)</span> + <span class="string">"="</span> encode<span class="constructor">URLComponent(<span class="params">data</span>[<span class="params">key</span>])</span>);<span class="comment">//中文转码</span></span><br><span class="line">    &#125;</span><br><span class="line">    return res.join(<span class="string">"&amp;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> ajax(options)&#123;</span><br><span class="line">    <span class="comment">//创建一个XMLHttpRequest对象</span></span><br><span class="line">    var xmlhttp,timer;</span><br><span class="line">    <span class="keyword">if</span> (window.XMLHttpRequest) &#123;</span><br><span class="line">        xmlhttp = <span class="keyword">new</span> <span class="constructor">XMLHttpRequest()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xml = <span class="keyword">new</span> <span class="constructor">ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求</span></span><br><span class="line">    <span class="keyword">let</span> str = onj2str(options.data);</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="keyword">type</span>.<span class="keyword">to</span><span class="constructor">LowerCase()</span><span class="operator"> === </span><span class="string">"get"</span>) &#123;</span><br><span class="line">        xmlhttp.<span class="keyword">open</span>(<span class="string">"GET"</span>, options.url + <span class="string">"?"</span> + str, <span class="literal">true</span>);</span><br><span class="line">        xmlhttp.send<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xmlhttp.<span class="keyword">open</span>(<span class="string">"POST"</span>, options.url, <span class="literal">true</span>);</span><br><span class="line">        xmlhttp.set<span class="constructor">RequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>)</span>;</span><br><span class="line">        xmlhttp.send(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//响应</span></span><br><span class="line">    xmlhttp.onreadystatechange = <span class="keyword">function</span> (ev2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState<span class="operator"> === </span><span class="number">4</span>)&#123;</span><br><span class="line">            clear<span class="constructor">Interval(<span class="params">timer</span>)</span>;</span><br><span class="line">            <span class="comment">//判断是否请求成功(Http状态码大于等于200，且小于300，和状态码等于304为请求成功)</span></span><br><span class="line">            <span class="keyword">if</span> (xmlhttp.status &gt;= <span class="number">200</span><span class="operator"> &amp;&amp; </span>xmlhttp.status &lt; <span class="number">300</span><span class="operator"> || </span>xmlhttp.status<span class="operator"> === </span><span class="number">304</span>) &#123;</span><br><span class="line">                option.success(xmlhttp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                option.error(xmlhttp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (option.timeout)&#123;</span><br><span class="line">        timer = set<span class="constructor">Interval(<span class="params">function</span> ()</span> &#123;</span><br><span class="line">            console.log(<span class="string">"中断请求"</span>);</span><br><span class="line">            xmlhttp.abort<span class="literal">()</span>;</span><br><span class="line">            clear<span class="constructor">Interval(<span class="params">timer</span>)</span>;</span><br><span class="line">        &#125;,option.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题优化配置</title>
    <url>/2020/04/06/Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天使用Hexo搭了一个博客，在不断优化过程中去不断的搜集教程，在这里我把自己使用到的方面记录下来，方便今后的查阅。</p>
<a id="more"></a>
<h2 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h2><p>在写博客的过程中，对markdown语法还不是特别熟悉，记录几个语法吧。</p>
<h3 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">半方大的空白   <span class="symbol">&amp;ensp;</span>  或  <span class="symbol">&amp;#8194;</span></span><br><span class="line">全方大的空白   <span class="symbol">&amp;emsp;</span>  或  <span class="symbol">&amp;#8195;</span></span><br><span class="line">不断行的空白格 <span class="symbol">&amp;nbsp;</span>  或  <span class="symbol">&amp;#160;</span></span><br></pre></td></tr></table></figure>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内式链接形式：[<span class="string">超链接文字</span>](<span class="link">url</span>) </span><br><span class="line">[百度]https://www.baidu.com)</span><br></pre></td></tr></table></figure>
<p><strong>在新窗口打开页面</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"/work/manager/index.html"</span> <span class="attribute">target</span>=<span class="string">"_blank"</span>&gt;共享单车后台管理系统&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p><a href="/work/manager/index.html" target="_blank">共享单车后台管理系统</a></p>
<h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(<span class="number">1</span>.jpg)  <span class="comment">//图片放在与文章同名的文件夹中</span></span><br></pre></td></tr></table></figure>
<h3 id="文字颜色"><a href="#文字颜色" class="headerlink" title="文字颜色"></a>文字颜色</h3><p>这是<label style="color:red">红色</label>字体</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">这是&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">"color:red"</span>&gt;红色&lt;/<span class="built_in">label</span>&gt;字体</span><br></pre></td></tr></table></figure>
<h2 id="Next主题优化"><a href="#Next主题优化" class="headerlink" title="Next主题优化"></a>Next主题优化</h2><h3 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h3><p>&emsp;&emsp;在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 <strong>阅读全文</strong> 按钮，可以通过以下方法：<br>1.在文章中使用<code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo 提供的方式<br>2.在文章的 <code>front-matter</code> 中添加 <code>description</code>，并提供文章摘录<br>3.自动形成摘要，在 <strong>主题配置文件</strong> 中添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>
<p>默认截取的长度为 150 字符，可以根据需要自行设定</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6（一）</title>
    <url>/2020/04/05/ES6/</url>
    <content><![CDATA[<p>今天来复习一下ES6的相关知识吧，打好每一个基础吧。那么开始吧</p>
<a id="more"></a> 

<h2 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul>
<li><p>代码块内有效</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&#123;let a = <span class="number">0</span>; var b = <span class="number">2</span>&#125; a <span class="comment">// 报错 ReferenceError: a is not defined b // 2</span></span><br></pre></td></tr></table></figure>
<p>  在代码块内，let声明的是局部变量；var声明的是全局变量</p>
</li>
<li><p>不能重发声明</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let a = <span class="number">1</span>; let a = <span class="number">2</span>; var b = <span class="number">3</span>; var b = <span class="number">4</span>; a  <span class="comment">// Identifier 'a' has already been declared b  // 4</span></span><br></pre></td></tr></table></figure>
<p>for循环很适合用let，var声明的i是全局变量，因此外部的i等于最后一次i的值。<br>let声明的i在每轮循环中都是新的变量。</p>
</li>
<li><p>let不存在变量提升</p>
</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li><code>const</code>声明一个只读变量，声明之后不允许改变，一旦声明必须初始化，否则会报错</li>
<li>暂时性死区<ul>
<li><code>const</code>和<code>let</code>一样，都是局部作用域的，因此在声明之前使用变量会报错。</li>
</ul>
</li>
<li>注意：<code>const</code>声明之后允许改变。<ul>
<li>简单数据类型，就是值不许改变。</li>
<li>复杂数据类型，是指向数据的指针不发生改变，数据结构可以改变，所以复杂数据类型要慎用。</li>
</ul>
</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="解构模型"><a href="#解构模型" class="headerlink" title="解构模型"></a>解构模型</h3><ul>
<li>解构的源：右边部分</li>
<li>解构的目标：左边部分<h3 id="数组模型的解构（Array）"><a href="#数组模型的解构（Array）" class="headerlink" title="数组模型的解构（Array）"></a>数组模型的解构（Array）</h3></li>
<li>基本<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// a=1,b=2,c=3</span></span><br></pre></td></tr></table></figure></li>
<li>可嵌套<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">let[a,<span class="string">[[b]，c]]</span> = [<span class="number">1</span>,<span class="string">[[2],3]]</span>;</span><br><span class="line">// a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li>可忽略<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [a, ,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//a = 1; b = 3</span></span><br></pre></td></tr></table></figure></li>
<li>不完全解构<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">1</span>, b] = [ ];</span><br><span class="line">// <span class="attr">a</span> = <span class="number">1</span> ; <span class="attr">b</span> = undefined;</span><br></pre></td></tr></table></figure></li>
<li>剩余运算符<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// a = 1; b = [2, 3]</span></span><br></pre></td></tr></table></figure></li>
<li>字符串等<br>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现iterator接口的数据。<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="regexp">//</span>a = <span class="string">'h'</span>; b = <span class="string">'e'</span>; c = <span class="string">'l'</span>; d = <span class="string">'l'</span>; e = <span class="string">'o'</span></span><br></pre></td></tr></table></figure></li>
<li>解构默认值<br>当解构模式有匹配结果，且匹配结果是undefined时，会触发默认值作为返回结果。<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">1</span>] = [undefined]；</span><br><span class="line">//<span class="attr">a</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = a] = [];     // <span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = a] = [<span class="number">1</span>];    // <span class="attr">a</span> = <span class="number">1</span>, <span class="attr">b</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = a] = [<span class="number">1</span>, <span class="number">2</span>]; // <span class="attr">a</span> = <span class="number">1</span>, <span class="attr">b</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="对象模型的解构（Object）"><a href="#对象模型的解构（Object）" class="headerlink" title="对象模型的解构（Object）"></a>对象模型的解构（Object）</h3></li>
<li>基本<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> &#125;; <span class="regexp">//</span> foo = <span class="string">'aaa'</span> <span class="regexp">//</span> bar = <span class="string">'bbb'</span> </span><br><span class="line">let &#123; baz : foo &#125; = &#123; baz : <span class="string">'ddd'</span> &#125;; <span class="regexp">//</span> foo = <span class="string">'ddd'</span></span><br></pre></td></tr></table></figure></li>
<li>可嵌套可忽略<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">let obj = &#123;<span class="string">p:</span> [<span class="string">'hello'</span>, &#123;<span class="string">y:</span> <span class="string">'world'</span>&#125;] &#125;; let &#123;<span class="string">p:</span> [x, &#123; y &#125;] &#125; = obj; <span class="comment">// x = 'hello' // y = 'world' </span></span><br><span class="line">let obj = &#123;<span class="string">p:</span> [<span class="string">'hello'</span>, &#123;<span class="string">y:</span> <span class="string">'world'</span>&#125;] &#125;; let &#123;<span class="string">p:</span> [x, &#123;  &#125;] &#125; = obj; <span class="comment">// x = 'hello'</span></span><br></pre></td></tr></table></figure></li>
<li>不完全解构</li>
<li>剩余运算符</li>
<li>默认解构值</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ES6引入新的原始数据类型Symbol，表示独一无二的值，类似字符串，常用作对象的属性名。<br>允许添加一个参数，作为标识。参数相同值也不相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">"KK"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sy);    <span class="comment">//Symbol(KK)</span></span><br><span class="line"><span class="keyword">typeof</span>(sy);  <span class="comment">// symbol</span></span><br><span class="line">相同参数symbol() 返回的值不相等。</span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">"KK"</span>);</span><br><span class="line">sy === sy1;   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h3><p>由于每个Symbol的值都不相等，因此可以用作对象的属性名。以前都是用字符串。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sy</span> = Symbol(<span class="string">"key1"</span>);</span><br><span class="line"></span><br><span class="line">写法<span class="number">1</span>   </span><br><span class="line"><span class="keyword">let</span> <span class="attr">syObj</span> = &#123;&#125;;</span><br><span class="line">    syObj[sy] = <span class="string">"kk"</span>;</span><br><span class="line">    console.log(syObj);    </span><br><span class="line">    // &#123;Symbol(key1) : <span class="string">"kk"</span>&#125;</span><br><span class="line"></span><br><span class="line">写法二   </span><br><span class="line"><span class="keyword">let</span> <span class="attr">syObj</span> = &#123;</span><br><span class="line">  ​  [sy]: <span class="string">"kk"</span>                 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">写法三    </span><br><span class="line"><span class="keyword">let</span> <span class="attr">syObj</span> = &#123;</span><br><span class="line">  ​  Object.defineProperty(syObj,sy,&#123;value:<span class="string">"kk&#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意：Symbol作为对象属性名时不能用  <strong>.</strong> 运算符，要用 <strong>[]</strong>，因为.运算符后面跟字符串，取到的是字符串属性。</p>
<h3 id="如何访问Symbol作为属性名的属性"><a href="#如何访问Symbol作为属性名的属性" class="headerlink" title="如何访问Symbol作为属性名的属性"></a>如何访问Symbol作为属性名的属性</h3><p>不会出现在 for…in 、 for…of 的循环中，也不会被·<code>Object.keys() 、 Object.getOwnPropertyNames()</code>返回。如果要读取到一个对象的 Symbol 属性，可以通过<code>Object.getOwnPropertySymbols()</code>和 <code>Reflect.ownKeys()</code>取到。</p>
<h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h3><p>Symbol.for(),首先会在全局搜索被登记的Symbol中是否有该字符串参数作为名称的Symbol值，如果有即返回该Symbol值，如果没有就会创建一个Symbol值并登记。</p>
<h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h3><p>返回一个已登记的Symbol类型值的key，用来检测该字符串参数作为名称的Symbol值是否已被登记。</p>
<h2 id="Map与Set"><a href="#Map与Set" class="headerlink" title="Map与Set"></a>Map与Set</h2><h3 id="Map对象"><a href="#Map对象" class="headerlink" title="Map对象"></a>Map对象</h3><ul>
<li>Map对象与Object对象的异同<ul>
<li>都是由键值对组成的</li>
<li>Map的键可以是任意类型，Object的键只能是字符串或Symbol</li>
<li>Map中的键值是有序的，Object的不是</li>
<li>Map的键值对个数可以从size属性中获取，Object只能手动计算</li>
<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突</li>
</ul>
</li>
<li>增删改查<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();  <span class="comment">//创建</span></span><br><span class="line">myMap.<span class="keyword">set</span>(<span class="string">"string"</span>,<span class="string">"相关的值"</span>)  <span class="comment">//添加键值对</span></span><br><span class="line">myMap.<span class="keyword">get</span>(<span class="string">"string"</span>)  <span class="comment">//   获取对应key的值 </span></span><br><span class="line">myMap.has(<span class="string">"string"</span>)   <span class="comment">//是否存在key“string”  ：true</span></span><br><span class="line">myMap.delete(<span class="string">"string"</span>)  <span class="comment">//删除key“string”</span></span><br></pre></td></tr></table></figure></li>
<li>Map中的key<ul>
<li>字符串</li>
<li>对象  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var obj =&#123; &#125;; myMap.<span class="builtin-name">get</span>(obj) !== myMap.<span class="builtin-name">get</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>函数<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">fun</span> =<span class="title">function</span> <span class="params">()</span></span>&#123; &#125;; myMap.<span class="keyword">get</span>(<span class="function"><span class="keyword">fun</span>) !== myMap.<span class="title">get</span><span class="params">(function()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>NaN<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var myNaN= NaN; myMap.<span class="builtin-name">get</span>(myNaN) === myMap.<span class="builtin-name">get</span>(Number(<span class="string">"string"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Set对象"><a href="#Set对象" class="headerlink" title="Set对象"></a>Set对象</h3></li>
</ul>
</li>
<li>Set对象允许存储任何类型的唯一值 。</li>
<li>Set中的特殊值<ul>
<li>+0和-0是恒等的，所以不重复</li>
<li>undefined与undefined是恒等的，不重复</li>
<li>NaN与Nan是不恒等的，但在Set中只能存在一个</li>
</ul>
</li>
<li>Set设置与读取<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">let mySet = <span class="built_in">new</span> <span class="keyword">Set</span>();</span><br><span class="line">mySet.<span class="keyword">add</span>(<span class="number">1</span>);  //<span class="keyword">Set</span>(<span class="number">1</span>)&#123;<span class="number">1</span>&#125;</span><br><span class="line">mySet.<span class="keyword">delete</span>(<span class="number">1</span>) 删除</span><br></pre></td></tr></table></figure></li>
<li>应用<ul>
<li>数组去重<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var mySet = new Set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">[...mySet];  <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li>
<li>并集<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="keyword">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="keyword">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]); </span><br><span class="line"><span class="keyword">var</span> <span class="keyword">union</span> = <span class="keyword">new</span> <span class="keyword">Set</span>([...a, ...b]); <span class="comment">// &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>交集<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line">var b = <span class="keyword">new</span> <span class="constructor">Set([4, 3, 2])</span>; </span><br><span class="line">var intersect = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; <span class="params">b</span>.<span class="params">has</span>(<span class="params">x</span>)</span>)); <span class="comment">// &#123;2, 3&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>差集<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line">var b = <span class="keyword">new</span> <span class="constructor">Set([4, 3, 2])</span>; </span><br><span class="line">var difference = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; !<span class="params">b</span>.<span class="params">has</span>(<span class="params">x</span>)</span>)); <span class="comment">// &#123;1&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="正则表达式-regular-expression"><a href="#正则表达式-regular-expression" class="headerlink" title="正则表达式(regular expression)"></a>正则表达式(regular expression)</h2><p>使用场景：匹配（验证用户名、邮箱啊）、替换敏感词、提取文字啊。。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/</span>);</span><br><span class="line"><span class="keyword">var</span> rg1 = <span class="regexp">/abc/</span>;</span><br></pre></td></tr></table></figure>

<p>一共两种方式，正则表达式必须写在<code>/  /</code>之间。不需要用<code>&#39;   &#39;</code>将字符串包起来。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">rg.test(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<p>正则表达式<code>.test（检测内容）</code>    返回<code>ture</code>、<code>false</code></p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>就是指的特殊字符<br>/abc/只要有abc 连在一起就可以</p>
<h4 id="边界符"><a href="#边界符" class="headerlink" title="边界符^   $"></a>边界符^   $</h4><ul>
<li><p>^表示以。。。开头   /^abc/  必须以abc开头</p>
</li>
<li><p>$表示以。。。结尾   /abc$/  必须以abc结尾</p>
</li>
<li><p>^  $ 表示精确匹配     /^abc$/  必须是abc才是true</p>
<h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类[ ]"></a>字符类[ ]</h4></li>
<li><p><code>[ ]</code>表示只能多选一。或者的关系<br> <code>/[abc]/</code>  只要包含有a 或者 包含有 b 或者 包含有c 就可以<br> <code>/^[abc]$/</code>  三选一，只要是有a 或者b 或者c 这三个字母才返回</p>
</li>
<li><p><code>[ - ]</code><br> <code>/^[a-z]$/</code>  26个英文字母任何一个字母就可以，必须是英文</p>
</li>
<li><p>字符组合<br> <code>/^[a-zA-Z0-9_-]$/</code></p>
</li>
<li><p>^取反<br> <code>/^[ ^ 123]$/</code>  <code>[ ]</code>内部的<code>^</code>表示取反，不能有里面的内容</p>
<h4 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h4></li>
<li><p>*相当于&gt;=0  可以出现0次或很多次</p>
</li>
<li><p>+相当于&gt;=1  可以出现1次或很多次</p>
</li>
<li><p>?相当于1||0      0次或者1次</p>
</li>
<li><p>{3}就是重复3次  / ^a{3}$/</p>
</li>
<li><p>{3,} 就是大于等于3</p>
</li>
<li><p>{3,16} 大于等于3，小于等于16</p>
</li>
<li><p><code>/^[a-zA-Z0-9_-]{6,16}$/</code>表示6-16位之间，必须从里面去选择</p>
</li>
<li><p><code>/^abc$/</code> 必须是abc</p>
</li>
<li><p><code>/^[abc]$/</code>  a或b或c</p>
</li>
<li><p><code>/^a{3}$/</code>  必须是aaa</p>
</li>
<li><p><code>/^abc{3}$/</code>  必须是abccc</p>
</li>
<li><p><code>/^(abc){3}$/</code>  abcabcabc </p>
</li>
<li><p>{ } 表示多少次</p>
</li>
<li><p>[ ]表示多选一</p>
</li>
<li><p>( )表示优先级</p>
<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3></li>
<li><p>某些模式的简写方式</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code></li>
<li><code>\D</code> 匹配0-9以外的字符，相当于<code>[ ^ 0-9]</code></li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[a-zA-Z0-9_]</code></li>
<li><code>\W</code> 除所有字母数字和下划线以外的字符，相当于<code>[ ^a-zA-Z0-9]</code></li>
<li><code>\s</code>  匹配空格（包括换行符、制表符、空格符等），相当于<code>[\t\r\n\v\f]</code></li>
<li><code>\S</code>匹配非空格的字符，相当于[ ^\t\r\n\v\f]</li>
</ul>
</li>
<li><p><code>/\w{6,16}/</code></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3></li>
<li><p>座机号码 两种格式：<code>010-12345678</code>  <code>0120-1234567</code><br><code>/\d{3}-\d{8}|\d{4}-\d{7}/</code></p>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>replace(原内容，新内容)</code></p>
</li>
<li><p><code>replace(/激情/，&quot;**&quot;)</code></p>
</li>
<li><p>/表达式/[switch]</p>
<ul>
<li>g  全局匹配 replace(/激情/g,’**’)   replace(/激情|gay/g,’ * *’)</li>
<li>i  忽略大小写</li>
<li>gi 全局匹配和忽略大小写</li>
</ul>
</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const fn = <span class="function"><span class="params">(name)</span>=&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;<span class="attr">name</span>:<span class="string">"张三"</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">​		<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">​	  <span class="keyword">return</span> <span class="function"><span class="params">( )</span> =&gt;</span> &#123;</span><br><span class="line">​		    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">​	  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  resFn = fn.call(obj);</span><br><span class="line">resFn();</span><br></pre></td></tr></table></figure>
<p>// 第一个this是obj对象，第二个this也是obj对象。<br><strong>箭头函数不绑定this关键字，箭头函数的this，指向的是函数定义位置的上下文this</strong>。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">​     age:<span class="number">20</span>;</span><br><span class="line">​			say:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">​				<span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">​			&#125;</span><br><span class="line">​	&#125;</span><br><span class="line">obj.say()  <span class="regexp">//</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>因为箭头函数定义在obj对象里，但是obj对象不能产生作用域，因此，箭头函数被定义在全局作用域下。this指向Window，所以是window对象下的age。如果此时有 var age = 100；则输出装值为100.</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>在箭头函数中，没有arguments哦~~</p>
<ul>
<li>收集剩余的参数，<strong>只能放在末尾</strong>！！！</li>
<li>展开数组，展开后的效果，就跟把数组的内容之间写在这儿一样。<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">sum</span> = (...<span class="keyword">args</span>) =&gt; &#123;</span><br><span class="line">  let <span class="keyword">total</span> = 0;</span><br><span class="line">  <span class="keyword">args</span>.<span class="keyword">forEach</span>(item =&gt; <span class="keyword">total</span> + item )</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">total</span> ;</span><br><span class="line">​&#125;</span><br><span class="line"><span class="built_in">sum</span>(10,20);</span><br><span class="line"><span class="built_in">sum</span>(10,20,30)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h2><p>详情见<a href="https://www.runoob.com/w3cnote/es6-reflect-proxy.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>一个 Proxy 对象由两个部分组成： <strong>target</strong> 、 <strong>handler</strong> 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, key) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getting '</span>+key);</span><br><span class="line">        <span class="keyword">return</span> target[key]; <span class="comment">// 不是target.key</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(target, key, value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setting '</span>+key);</span><br><span class="line">        target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">proxy.name     <span class="comment">// 实际执行 handler.get</span></span><br><span class="line">proxy.age = <span class="number">25</span> <span class="comment">// 实际执行 handler.set</span></span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// setting age</span></span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// target 可以为空对象</span></span><br><span class="line"><span class="keyword">let</span> targetEpt = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEpt = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEpt, handler)</span><br><span class="line"><span class="comment">// 调用 get 方法，此时目标对象为空，没有 name 属性</span></span><br><span class="line">proxyEpt.name <span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// 调用 set 方法，向目标对象中添加了 name 属性</span></span><br><span class="line">proxyEpt.name = <span class="string">'Tom'</span></span><br><span class="line"><span class="comment">// setting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"><span class="comment">// 再次调用 get ，此时已经存在 name 属性</span></span><br><span class="line">proxyEpt.name</span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相</span></span><br><span class="line"><span class="comment">// 影响</span></span><br><span class="line">targetEpt)</span><br><span class="line"><span class="comment">// &#123;name: "Tom"&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象</span></span><br><span class="line"><span class="keyword">let</span> targetEmpty = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEmpty = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEmpty,&#123;&#125;)</span><br><span class="line">proxyEmpty.name = <span class="string">"Tom"</span></span><br><span class="line">targetEmpty) <span class="comment">// &#123;name: "Tom"&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实例方法</li>
</ul>
<p><strong>get(target, propKey, receiver)</strong><br>用于 target 对象上 propKey 的读取操作。get() 方法可以继承。<br><strong>set(target, propKey, value, receiver)</strong><br>用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。<br><strong>apply(target, ctx, args)</strong><br>用于拦截函数的调用、call 和 reply 操作。target 表示目标对象，ctx 表示目标对象上下文，args 表示目标对象的参数数组。<br><strong>has(target, propKey)</strong><br>用于拦截 HasProperty 操作，即在判断 target 对象是否存在 propKey 属性时，会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。</p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p><strong>Reflect.get(target, name, receiver)</strong><br>查找并返回 target 对象的 name 属性。<br><strong>Reflect.set(target, name, value, receiver)</strong><br>将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错。<br><strong>Reflect.has(obj, name)</strong><br>是 name in obj 指令的函数化，用于查找 name 属性在 obj 对象中是否存在。返回值为 boolean。如果 obj 不是对象则会报错 TypeError。<br><strong>Reflect.deleteProperty(obj, property)</strong><br>是 delete obj[property] 的函数化，用于删除 obj 对象的 property 属性，返回值为 boolean。如果 obj 不是对象则会报错 TypeError。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>安恒信息笔试总结</title>
    <url>/2020/04/12/%E5%AE%89%E6%81%92%E4%BF%A1%E6%81%AF%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今日份的笔试</p>
<a id="more"></a>
<h2 id="选择部分"><a href="#选择部分" class="headerlink" title="选择部分"></a>选择部分</h2><h3 id="哪些事件是冒泡"><a href="#哪些事件是冒泡" class="headerlink" title="哪些事件是冒泡"></a>哪些事件是冒泡</h3><p>不是所有事件都冒泡，记住不冒泡的就好啦。<br>blur、focus、load、unload、abort、error、mouseenter、mouseleave、resize、DOMNodeInsertedIntoDocument、DOMNodeRemovedFromDocument是不冒泡的；media相关事件，都不冒泡</p>
<h3 id="哪些是兄弟选择器"><a href="#哪些是兄弟选择器" class="headerlink" title="哪些是兄弟选择器"></a>哪些是兄弟选择器</h3><p>相邻兄弟选择器  div+p<br>后续兄弟选择器  div~p</p>
<h3 id="堆排序的初始堆"><a href="#堆排序的初始堆" class="headerlink" title="堆排序的初始堆"></a>堆排序的初始堆</h3><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
<h3 id="svg-jpeg-gif-png"><a href="#svg-jpeg-gif-png" class="headerlink" title="svg/jpeg/gif/png"></a>svg/jpeg/gif/png</h3><p><strong>JPEG</strong><br>采用特殊的<span style="color:#EC7259">有损压缩</span>算法，将不易被人眼察觉的图像颜色删除，从而达到较大的压缩比(可达到2:1甚至40:1)，因为JPEG格式的文件尺寸较小，下载速度快,所以是互联网上最广泛使用的格式。<br><strong>GIF</strong><br>不仅可以是一张静止的图片,也可以是<span style="color:#EC7259">动画</span>，并且支持<span style="color:#EC7259">透明背景图像</span>，适用于多种操作系统，“体型”很小，网上很多小动画都是GIF格式。但是其<span style="color:#EC7259">色域不广</span>,只支持256种颜色。<br><strong>PNG</strong><br>与JPG格式类似,网页中有很多图片都是这种格式，压缩比高于GIF，支持<span style="color:#EC7259">图像透明</span>，可以利用Alpha通道调节图像的透明度,是网页三剑客之一Fireworks的源文件。<br><strong>BMP</strong><br>Windows系统下的标准位图格式,未经过压缩，一般图像文件会比较大。在很多软件中被广泛应用。<br><strong>SVG</strong><br>它的英文全称为Scalable Vector Graphics，意思为可缩放的矢量图形。用户可以直接<span style="color:#EC7259">用代码来描绘图像</span>，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来观看。</p>
<p>链接：<a href="https://www.jianshu.com/p/6e1941de7952" target="_blank" rel="noopener">https://www.jianshu.com/p/6e1941de7952</a></p>
<h2 id="简答部分"><a href="#简答部分" class="headerlink" title="简答部分"></a>简答部分</h2><h3 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h3><p>SQL Injection：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。<br><a href="https://blog.csdn.net/qq_34638225/article/details/81269281" target="_blank" rel="noopener">https://blog.csdn.net/qq_34638225/article/details/81269281</a></p>
<h3 id="JavaScript-Prototype污染攻击漏洞的原理"><a href="#JavaScript-Prototype污染攻击漏洞的原理" class="headerlink" title="JavaScript Prototype污染攻击漏洞的原理"></a>JavaScript Prototype污染攻击漏洞的原理</h3><p>关键词：prototype   <strong>proto</strong>  原型链 继承，原型上的属性被修改，则继承构造函数的实例的属性也会被修改。<br><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x01-prototype__proto" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x01-prototype__proto</a>__</p>
<h3 id="简述HTTP与HTTPS及区别"><a href="#简述HTTP与HTTPS及区别" class="headerlink" title="简述HTTP与HTTPS及区别"></a>简述HTTP与HTTPS及区别</h3><p><strong>HTTP</strong>：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br><strong>HTTPS</strong>：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p><strong>HTTPS和HTTP的区别主要如下：</strong><br>1.HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。<br>2.使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。<br>3.HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。<br>4.http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>5.HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。<br><a href="https://www.runoob.com/w3cnote/http-vs-https.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/http-vs-https.html</a><br>TCP三次握手</p>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS之我的知识盲区系列（二）</title>
    <url>/2020/04/09/CSS%E4%B9%8B%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>记录关于CSS的遗忘知识点。</p>
<a id="more"></a>

<h2 id="CSS文本"><a href="#CSS文本" class="headerlink" title="CSS文本"></a>CSS文本</h2><h3 id="装饰文字"><a href="#装饰文字" class="headerlink" title="装饰文字"></a>装饰文字</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">text-decoraton:underline; <span class="comment">//下划线</span></span><br><span class="line">text-decoraton:overline; <span class="comment">//上划线</span></span><br><span class="line">text-decoraton:overthrough; <span class="comment">//删除线</span></span><br><span class="line">text-decoraton:none; <span class="comment">//无</span></span><br></pre></td></tr></table></figure>
<h3 id="文字大小写转换"><a href="#文字大小写转换" class="headerlink" title="文字大小写转换"></a>文字大小写转换</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">text</span>-<span class="keyword">transform</span>:uppercase;</span><br><span class="line"><span class="type">text</span>-<span class="keyword">transform</span>:lowercase;</span><br><span class="line"><span class="type">text</span>-<span class="keyword">transform</span>:uppercase;</span><br></pre></td></tr></table></figure>
<h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-indent</span>:<span class="number">50px</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字符之间的空间"><a href="#字符之间的空间" class="headerlink" title="字符之间的空间"></a>字符之间的空间</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">letter-spacing</span>:<span class="number">5px</span>;</span><br><span class="line"><span class="attribute">letter-spacing</span>:-<span class="number">3px</span>;</span><br></pre></td></tr></table></figure>
<h3 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">line</span>-<span class="built_in">height</span>:<span class="number">30</span>px;</span><br></pre></td></tr></table></figure>
<h3 id="文字方向"><a href="#文字方向" class="headerlink" title="文字方向"></a>文字方向</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">direction</span>:rtl;  <span class="comment">//right to left</span></span><br><span class="line"><span class="attribute">direction</span>:ltr;  <span class="comment">//left to right</span></span><br></pre></td></tr></table></figure>
<p><strong>注意后者，如果结尾有标点符号，会移动至最左边奥~因为开头不能有标点吧！</strong></p>
<h3 id="禁用文字换行"><a href="#禁用文字换行" class="headerlink" title="禁用文字换行"></a>禁用文字换行</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">white-<span class="literal">space</span>:nowrap</span><br></pre></td></tr></table></figure>
<h3 id="位于同一行的文字与图片的居中对齐"><a href="#位于同一行的文字与图片的居中对齐" class="headerlink" title="位于同一行的文字与图片的居中对齐"></a>位于同一行的文字与图片的居中对齐</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">vertical-align:<span class="keyword">middle</span></span><br></pre></td></tr></table></figure>
<h2 id="CSS文字"><a href="#CSS文字" class="headerlink" title="CSS文字"></a>CSS文字</h2><h3 id="文字异体"><a href="#文字异体" class="headerlink" title="文字异体"></a>文字异体</h3><p>将小写字母转为小型的大写</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-variant</span>:small-caps</span><br><span class="line">&lt;<span class="selector-tag">span</span> style=<span class="string">"font-variant:small-caps"</span>&gt;Small&lt;/span&gt; <span class="comment">//效果如下所示</span></span><br></pre></td></tr></table></figure>
<p><span style="font-variant:small-caps">Small</span></p>
<h2 id="CSS列表"><a href="#CSS列表" class="headerlink" title="CSS列表"></a>CSS列表</h2><h3 id="列表的标记类型"><a href="#列表的标记类型" class="headerlink" title="列表的标记类型"></a>列表的标记类型</h3><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">list</span>-style-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>具体样式可查阅 <a href="https://www.runoob.com/cssref/pr-list-style-type.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<h3 id="自定义标记类型"><a href="#自定义标记类型" class="headerlink" title="自定义标记类型"></a>自定义标记类型</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">list-style-image</span><span class="selector-pseudo">:url()</span></span><br><span class="line"><span class="selector-tag">background-img</span><span class="selector-pseudo">:url()</span> 也可以实现</span><br><span class="line">使用伪元素：</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS表格"><a href="#CSS表格" class="headerlink" title="CSS表格"></a>CSS表格</h2><h3 id="标题位置"><a href="#标题位置" class="headerlink" title="标题位置"></a>标题位置</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">caption-side:<span class="built_in">bottom</span>/<span class="built_in">top</span>/inherit</span><br></pre></td></tr></table></figure>
<h2 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h2><h3 id="裁剪图片"><a href="#裁剪图片" class="headerlink" title="裁剪图片"></a>裁剪图片</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">img </span><br><span class="line">&#123;</span><br><span class="line">position:absolute;  <span class="comment">//必须设置绝对定位</span></span><br><span class="line">clip:rect(<span class="number">0</span>px,<span class="number">60</span>px,<span class="number">200</span>px,<span class="number">0</span>px); <span class="comment">//四个值表示：上右下左裁剪线</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>拼多多笔试总结</title>
    <url>/2020/04/10/%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今日份的笔试总结，凭记忆啦~</p>
<a id="more"></a>

<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><h3 id="http的特点"><a href="#http的特点" class="headerlink" title="http的特点"></a>http的特点</h3><p>HTTP协议的主要特点可概括如下：</p>
<p>1.<strong>支持客户/服务器模式</strong>。</p>
<p>2.<strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>3.<strong>灵活</strong>：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</p>
<p>4.<strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>5.<strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</p>
<h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max()"></a>Math.max()</h3><p>Math.max(value1[,value2, …]);<br>Math.max.apply(null, numberArray);<br>Math.max.call(null, value1[,value2,…]);<br>返回给定的一组数字中的最大值。如果给定的参数中至少有一个参数无法被转换成数字，则会返回 NaN。<br>由于 max 是 Math 的静态方法，所以应该像这样使用：Math.max()，而不是创建的 Math 实例的方法（Math 不是构造函数）。<br>如果没有参数，则结果为 - Infinity。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">console.log(Math.max(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)); <span class="comment">//3</span></span><br><span class="line">console.log(Math.max([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">//NaN</span></span><br><span class="line">console.log(Math.max.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">//3</span></span><br><span class="line">console.log(Math.max.call(<span class="literal">null</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h3 id="flex-flow是哪两个属性"><a href="#flex-flow是哪两个属性" class="headerlink" title="flex-flow是哪两个属性"></a>flex-flow是哪两个属性</h3><p>详见另外一篇css讲解：<a href="https://evelyn-lin.gitee.io/2020/04/08/CSS%E4%B9%8B%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">CSS之我的知识盲区(一)</a></p>
<h3 id="ip地址的分类和子网掩码"><a href="#ip地址的分类和子网掩码" class="headerlink" title="ip地址的分类和子网掩码"></a>ip地址的分类和子网掩码</h3><table>
<thead>
<tr>
<th>类别</th>
<th>IP地址范围</th>
<th>私网IP地址范围</th>
<th>子网掩码</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>1.0.0.1-127.255.255.254</td>
<td>10.0.0.0-10.255.255.255</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B</td>
<td>128.0.0.1-191.255.255.254</td>
<td>172.16.0.0-172.31.255.255</td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C</td>
<td>192.0.0.1-223.255.255.254</td>
<td>192.168.0.0-192.168.255.255</td>
<td>255.255.255.0</td>
</tr>
</tbody></table>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="浏览器本地存储的三种方式"><a href="#浏览器本地存储的三种方式" class="headerlink" title="浏览器本地存储的三种方式"></a>浏览器本地存储的三种方式</h3><p>cookie localStorage  sessionStorage<br><a href="https://segmentfault.com/a/1190000012607546" target="_blank" rel="noopener">总结本地存储的几种方式</a><br><a href="https://mp.weixin.qq.com/s/oOGIuJCplPVW3BuIx9tNQg" target="_blank" rel="noopener">这一次带你彻底了解cookie</a></p>
<h3 id="字符串和数值的加法运算"><a href="#字符串和数值的加法运算" class="headerlink" title="字符串和数值的加法运算"></a>字符串和数值的加法运算</h3><p>在加法/减法运算中，true和false会转换为1和0，null也是0，undefined参与的运算为NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="number">5</span>); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="string">'5'</span>); <span class="comment">// '55'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="literal">true</span>); <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="literal">false</span>); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="literal">undefined</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="literal">null</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<h3 id="重排与重绘"><a href="#重排与重绘" class="headerlink" title="重排与重绘"></a>重排与重绘</h3><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="js执行机制"><a href="#js执行机制" class="headerlink" title="js执行机制"></a>js执行机制</h3><p>同步任务与异步任务<br>微任务与宏任务  promise async await<br><a href="https://blog.csdn.net/ZD717822023/article/details/97491152" target="_blank" rel="noopener">JS执行机制详解</a></p>
<h3 id="函数this指向问题，包括匿名函数、ES6对象方法简写中的this、自执行函数"><a href="#函数this指向问题，包括匿名函数、ES6对象方法简写中的this、自执行函数" class="headerlink" title="函数this指向问题，包括匿名函数、ES6对象方法简写中的this、自执行函数"></a>函数this指向问题，包括匿名函数、ES6对象方法简写中的this、自执行函数</h3><p>方法中的this，指向方法的调用者；<br>普通函数的this，指向他的调用者；<br>箭头函数的this，永远指向上下文，注意call、apply的情况；<br>构造函数的this，指向他的实例；<br><a href="https://blog.csdn.net/dreamjay1997/article/details/81978921" target="_blank" rel="noopener">函数里的this指向问题</a></p>
<h3 id="写出能返回数组中相同元素的方法"><a href="#写出能返回数组中相同元素的方法" class="headerlink" title="写出能返回数组中相同元素的方法"></a>写出能返回数组中相同元素的方法</h3><p>先写一个自己答的方法吧~<br>方法一：利用sort方法，先使用sort方法将数组排序，再来判断找出重复元素</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">same</span><span class="params">(arr)</span> &#123;</span></span><br><span class="line">    arr.<span class="built_in">sort</span>();</span><br><span class="line">    let newArr = [];</span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="built_in">i</span>] == arr[<span class="built_in">i</span>+<span class="number">1</span>]) &#123;</span><br><span class="line">            newArr.push(arr[<span class="built_in">i</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...new Set(newArr)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的有点复杂，修改了一下，好像复杂程度也差不多。。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">same</span><span class="params">(arr)</span> &#123;</span></span><br><span class="line">    arr.<span class="built_in">sort</span>();</span><br><span class="line">    let newArr = [];</span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="built_in">i</span>] == arr[<span class="built_in">i</span>+<span class="number">1</span>] &amp;&amp; !newArr.includes( arr[<span class="built_in">i</span>] )) &#123;</span><br><span class="line">            newArr.push(arr[<span class="built_in">i</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：利用sort方法，先使用sort方法将数组排序，再来判断找出重复元素</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span><span class="params">(arr)</span></span>&#123;</span><br><span class="line">    var temp=[];</span><br><span class="line">    arr.<span class="built_in">sort</span>().<span class="built_in">sort</span>(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a===b&amp;&amp;temp.indexOf(a)===<span class="number">-1</span>)&#123;</span><br><span class="line">        temp.push(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三：对数组每一项循环，判断它的第一个位置和最后一个位置只要不一样就是重复值，然后在判断放置重复值的数组有没有这个值</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> res(arr) &#123;</span><br><span class="line">    var temp = <span class="literal">[]</span>;</span><br><span class="line">    arr.for<span class="constructor">Each(<span class="params">function</span> (<span class="params">item</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.index<span class="constructor">Of(<span class="params">item</span>)</span> !== arr.last<span class="constructor">IndexOf(<span class="params">item</span>)</span><span class="operator"> &amp;&amp; </span>temp.index<span class="constructor">Of(<span class="params">item</span>)</span><span class="operator"> === </span>-<span class="number">1</span>) &#123;</span><br><span class="line">            temp.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性结构与树形结构相互转换"><a href="#线性结构与树形结构相互转换" class="headerlink" title="线性结构与树形结构相互转换"></a>线性结构与树形结构相互转换</h3><p>当树形结构的层级越来越深时，操作某一节点会变得越来越费劲，维护成本不断增加。所以线性结构与树形的相互转换变得异常重要。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">树形结构</span></span><br><span class="line"></span><br><span class="line"><span class="string">list</span> <span class="string">=</span> <span class="string">[</span></span><br><span class="line">   <span class="string">&#123;</span> <span class="attr">id:</span> <span class="string">number,</span> <span class="attr">parentId:</span> <span class="string">number,</span> <span class="attr">name:</span> <span class="string">string</span> <span class="string">&#125;,</span> </span><br><span class="line">   <span class="string">&#123;</span> <span class="attr">id:</span> <span class="string">number,</span> <span class="attr">parentId:</span> <span class="string">number,</span> <span class="attr">name:</span> <span class="string">string</span> <span class="string">&#125;,</span></span><br><span class="line"><span class="string">];</span></span><br><span class="line"><span class="string">面的树形结构并不是很完美，当遇到菜单或者分类等业务场景时，每个顶级节点的parentId约定为0，当存在多个顶级节点，显得不是一个完整的树。所以在这类特殊情况下，我们需要构造一个顶级节点。将菜单或者分类的原有顶级节点存储至该节点的children中。</span> <span class="string">所以最后约定顶级节点如下。</span></span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">number,</span>  <span class="string">//</span> <span class="string">数值</span></span><br><span class="line">  <span class="attr">parentId:</span> <span class="string">number,</span>  <span class="string">//</span> <span class="string">数值</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string,</span></span><br><span class="line">  <span class="attr">children:</span> <span class="string">[]</span> <span class="string">||</span> <span class="literal">null</span><span class="string">,</span>  <span class="string">//</span> <span class="string">用数组的方式保存子节点，适合更多业务场景</span>  </span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">线性结构</span></span><br><span class="line"><span class="string">root</span> <span class="string">=</span> <span class="literal">null</span> <span class="string">||</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">id:</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line">  <span class="attr">parentId:</span> <span class="literal">null</span><span class="string">,</span></span><br><span class="line">  <span class="attr">children:</span> <span class="string">[node1,</span> <span class="string">node2,</span> <span class="string">...],</span>  </span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>线性结构转树形结构</strong></p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listConvertTree</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> &amp;&amp; <span class="built_in">list</span>.length) &#123;</span><br><span class="line">        root = &#123;<span class="attribute">id:</span><span class="string"> 0, parent</span>: <span class="literal">null</span>, <span class="attribute">children</span>: [] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> group = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>[i].parentId !== <span class="literal">null</span> &amp;&amp; <span class="built_in">list</span>[i].parentId !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!group[<span class="built_in">list</span>[i].parentId]) &#123;</span><br><span class="line">                group[<span class="built_in">list</span>[i].parentId] = []; <span class="comment">//group=&#123;[]&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            group[<span class="built_in">list</span>[i].parentId].push(<span class="built_in">list</span>[i]); <span class="comment">//group=&#123;[&#123; id: number, parentId: number, name: string &#125; ]&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">        node.children = group[node.id] &amp;&amp; group[node.id].length ? group[node.id] : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">                queue.push(...node.children);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">list</span> = [ </span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">0</span>, <span class="attribute">id:</span><span class="string"> 1, value</span>: <span class="string">'1'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">3</span>, <span class="attribute">id:</span><span class="string"> 2, value</span>: <span class="string">'2'</span> &#125;, </span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">0</span>, <span class="attribute">id:</span><span class="string"> 3, value</span>: <span class="string">'3'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">1</span>, <span class="attribute">id:</span><span class="string"> 4, value</span>: <span class="string">'4'</span> &#125;, </span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">1</span>, <span class="attribute">id:</span><span class="string"> 5, value</span>: <span class="string">'5'</span> &#125;, </span><br><span class="line">]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listToTree</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//遍历整个列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>.filter(cur=&gt;&#123; </span><br><span class="line">        <span class="comment">// 获取当前节点的子节点</span></span><br><span class="line">        <span class="keyword">let</span> children= <span class="built_in">list</span>.filter(item=&gt; item.parentId == cur.id ); </span><br><span class="line">        <span class="keyword">if</span>(children.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             cur.children=children;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只返回顶级节点</span></span><br><span class="line">        <span class="keyword">return</span> cur.parentId==<span class="number">0</span>; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔试</category>
      </categories>
  </entry>
  <entry>
    <title>使用hexo过程中遇到的坑</title>
    <url>/2020/04/04/hexo%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天突然心血来潮，想要自己搭建一个博客，正好可以将以前的笔记给系统整理一下。我的博客是使用<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>进行搭建的，跟着网上的教程一步一步的来，却不曾想老是碰见一些问题，不得不去查了好多资料来。在这里就记录几个自己在使用hexo过程中遇到的问题以及记录一下解决的方法。</p>
<a id="more"></a> 

<h2 id="各种问题"><a href="#各种问题" class="headerlink" title="各种问题"></a>各种问题</h2><h3 id="本地测试的时候刷新无效"><a href="#本地测试的时候刷新无效" class="headerlink" title="本地测试的时候刷新无效"></a>本地测试的时候刷新无效</h3><p>优化主题时，修改文件根目录下的<code>_config.yml</code>站点配置目录后，要重新启动Hexo再刷新，修改next主题目录下的<code>_config.yml</code>主题配置目录则只需刷新即可.</p>
<h3 id="使用npm安装插件报错"><a href="#使用npm安装插件报错" class="headerlink" title="使用npm安装插件报错"></a>使用npm安装插件报错</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> ERR! Cannot read property <span class="string">'match'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">npm</span> ERR! A complete log <span class="keyword">of</span> <span class="keyword">this</span> run can be found in:</span><br><span class="line"><span class="built_in">npm</span> ERR!     C:\Users\Administrator\AppData\Roaming\<span class="built_in">npm</span>-cache\_logs\<span class="number">2020</span><span class="number">-04</span><span class="number">-04</span>T12_05_08_782Z-debug.log</span><br></pre></td></tr></table></figure>

<p><code>npm cache clear --force</code>   清除npm本地缓存<br>如果不行，就删除 <code>package-lock.json</code> （这两个办法能够解决我目前遇到的这种情况）<br>再不行的话，就依次执行以下代码：<br>    <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rm</span> <span class="string">-rf node_modules</span></span><br><span class="line"><span class="attr">rm</span> <span class="string">package-lock.json</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">cache clear --force</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure></p>
<h3 id="hexo-helper-live2d相关报错"><a href="#hexo-helper-live2d相关报错" class="headerlink" title="hexo-helper-live2d相关报错"></a>hexo-helper-live2d相关报错</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>Plugin load failed: hexo-helper-live2d</span><br><span class="line"><span class="keyword">Error: </span>Cannot find module 'live2d-widget/lib/manifest'</span><br><span class="line">Require stack:</span><br></pre></td></tr></table></figure>
<p>想要放一个2d模型来着，于是乎跟着教程一边做着，就是运行不起来，最后连正常的页面都显示不了<br>最后通过上一个问题的方法，再加上 <code>hexo clean</code> 解决</p>
<h3 id="hexo-s-报错"><a href="#hexo-s-报错" class="headerlink" title="hexo s 报错"></a>hexo s 报错</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">FATAL bad indentation <span class="keyword">of</span> a <span class="keyword">mapping</span> entry at <span class="type">line</span> <span class="number">103</span>, <span class="keyword">column</span> <span class="number">7</span>:</span><br><span class="line">      <span class="keyword">type</span>: git</span><br><span class="line">          ^</span><br></pre></td></tr></table></figure>
<p>这种问题就是常见的语法错误啦，属性的后面应该跟 <code>英文字符的冒号</code>，再跟值</p>
<h3 id="文章中设置超链接跳转到本地html文件"><a href="#文章中设置超链接跳转到本地html文件" class="headerlink" title="文章中设置超链接跳转到本地html文件"></a>文章中设置超链接跳转到本地html文件</h3><p>因为每次运行<code>hexo g</code>的时候，会自动将文件进行编译，会给文本添加格式与标签<br>如果想要设置自定义页面,首先将自定义的页面放入<code>/resource</code>文件下,这个文件下的所有文件最终会直接放到<code>public</code>静态文件夹中，想要引入里面的文件，直接引用路径即可。<br>为了避免html被编译，需要设置 跳过渲染 ,在配置文件<code>.config.yml</code>中进行配置。下面举个例子：</p>
<p><code>/resource</code> 文件目录下创建了一个 <code>work</code> 文件夹,此时需要引入 <code>work</code> 下面的 <code>index.html</code> 文件，需要在配置文件<code>.config.yml</code>中设置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">skip_render:</span></span><br><span class="line">    - <span class="string">'work/**'</span></span><br><span class="line"></span><br><span class="line">引入的时候只需要使用 `![](<span class="regexp">/work/</span>index.html)`</span><br></pre></td></tr></table></figure>
<h3 id="重新部署的问题"><a href="#重新部署的问题" class="headerlink" title="重新部署的问题"></a>重新部署的问题</h3><p>每次重新推送到gitee之后刷新页面都没有更新，但是在本地运行明明是OK的。最开始怎么也发现不了问题在哪里，最后脑壳都蒙圈了，发现竟然是gitee的pages服务需要手动刷新。。。。<br>这算是最我进的最大的坑了吧。。。<br><img src="/2020/04/04/hexo%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt></p>
<h3 id="插入图片无法显示的问题"><a href="#插入图片无法显示的问题" class="headerlink" title="插入图片无法显示的问题"></a>插入图片无法显示的问题</h3><p>如何在文章中插入图片？</p>
<ul>
<li><p>先要将配置<code>_config.yml</code>里面的<code>post_asset_folder:false</code>这个选项设置为<code>true</code>。</p>
</li>
<li><p><code>npm install hexo-asset-image</code>,这样运行<code>hexo n &quot;xxx&quot;</code>来生成博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹，把图片放入该文件夹。（也可以手动创建同名文件夹）</p>
</li>
<li><p>再使用<code>![xxx](xxx/xxx.png)</code>引入图片</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">link</span> <span class="keyword">as</span>:<span class="comment">--&gt;/.com//1.png</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">link</span> <span class="keyword">as</span>:<span class="comment">--&gt;/.com//2.png</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">link</span> <span class="keyword">as</span>:<span class="comment">--&gt;/.com//3.png</span></span><br></pre></td></tr></table></figure>
<p>如果<code>hexo s</code>运行时出现上面代码，但是图片依旧不显示,是由于hexo3版本后对很多插件支持有问题<br>可直接安装已经修改过得插件<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code></p>
<p>注意每次都要使用 <code>hexo clean</code> 删除静态文件再重新运行奥~</p>
<p>感谢<br><a href="https://blog.csdn.net/sinat_42338962/article/details/94388760" target="_blank" rel="noopener">https://blog.csdn.net/sinat_42338962/article/details/94388760</a><br><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">https://www.jianshu.com/p/3db6a61d3782</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>共享单车管理系统之框架之主页面架构设计</title>
    <url>/2020/04/05/%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>前一段时间跟着视频的学习一步一步完成了 共享单车管理系统 的开发，本次想要重新再回顾一遍，自己动手开始吧~</p>
<a id="more"></a> 

<h2 id="两种方式创建一个react应用"><a href="#两种方式创建一个react应用" class="headerlink" title="两种方式创建一个react应用"></a>两种方式创建一个react应用</h2><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">npm </span><span class="string">install </span><span class="built_in">create-react-app</span> -g</span><br><span class="line"><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">npx </span><span class="string">install </span><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br></pre></td></tr></table></figure>
<p>直接使用官方的脚手架吧~<br><code>npm start</code>运行</p>
<h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><h3 id="全局安装yarn"><a href="#全局安装yarn" class="headerlink" title="全局安装yarn"></a>全局安装yarn</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> yarn -g</span><br></pre></td></tr></table></figure>
<h3 id="安装react-router"><a href="#安装react-router" class="headerlink" title="安装react-router"></a>安装<code>react-router</code></h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> react-router-dom --save</span></span><br></pre></td></tr></table></figure>
<h3 id="安装AntD"><a href="#安装AntD" class="headerlink" title="安装AntD"></a>安装AntD</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">yarn add <span class="symbol">antd@</span><span class="number">3.4</span><span class="number">.3</span> --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="安装less-less-loader-因为ant-d是基于less开发的"><a href="#安装less-less-loader-因为ant-d是基于less开发的" class="headerlink" title="安装less less-loader 因为ant-d是基于less开发的"></a>安装less less-loader 因为ant-d是基于less开发的</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yarn add <span class="keyword">less</span> <span class="keyword">less</span>-loader --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="初始化git并且提交"><a href="#初始化git并且提交" class="headerlink" title="初始化git并且提交"></a>初始化git并且提交</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git <span class="keyword">add</span><span class="bash"> ./</span></span><br><span class="line">git commit -m <span class="string">'1 commit'</span></span><br></pre></td></tr></table></figure>
<h3 id="暴露webpack配置文件"><a href="#暴露webpack配置文件" class="headerlink" title="暴露webpack配置文件"></a>暴露webpack配置文件</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">yarn eject  <span class="regexp">//</span>执行之前必须先提交,否则会报以下错误</span><br><span class="line"></span><br><span class="line">Remove untracked files, stash or commit any changes, and try again.</span><br><span class="line">error Command failed with <span class="keyword">exit</span> code <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件，使用less-loader去解析less文件"><a href="#修改配置文件，使用less-loader去解析less文件" class="headerlink" title="修改配置文件，使用less-loader去解析less文件"></a>修改配置文件，使用<code>less-loader</code>去解析<code>less</code>文件</h3><p>  找到<code>config</code>文件下的<code>webpack.config.js</code>文件,找到并修改第48和110行<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// style files regexes</span></span><br><span class="line"><span class="keyword">const</span> cssRegex = <span class="regexp">/\.(css|less)$/</span>; <span class="comment">//修改第48行</span></span><br><span class="line"><span class="keyword">const</span> cssModuleRegex = <span class="regexp">/\.module\.css$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassRegex = <span class="regexp">/\.(scss|sass)$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassModuleRegex = <span class="regexp">/\.module\.(scss|sass)$/</span>;</span><br></pre></td></tr></table></figure><br>  <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds PostCSS Normalize as the reset css with default options,</span></span><br><span class="line">           <span class="comment">// so that it honors browserslist config in package.json</span></span><br><span class="line">           <span class="comment">// which in turn let's users customize the target behavior as per their needs.</span></span><br><span class="line">           <span class="selector-tag">postcssNormalize</span>(),</span><br><span class="line">         ],</span><br><span class="line">         <span class="selector-tag">sourceMap</span>: <span class="selector-tag">isEnvProduction</span> <span class="selector-tag">&amp;</span><span class="selector-tag">&amp;</span> <span class="selector-tag">shouldUseSourceMap</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attribute">loader</span>:require.resolve(<span class="string">'less-loader'</span>)    <span class="comment">//修改行</span></span><br><span class="line">     &#125;</span><br><span class="line">   ]<span class="selector-class">.filter</span>(Boolean);</span><br></pre></td></tr></table></figure><br>由于use数组的执行顺序是从后到前，故在最下方添加<code>less-loader</code>加载则会被最先执行。修改完文件内容后需要重启项目<code>yarn start</code>生效。</p>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>因为每次使用ant-d组件的时候，都要引入ant-d.css样式文件，但实际上我们并不需要所有组件的样式。<br>为了提高性能，我们希望只引入我们使用到的组件的样式，实现<strong>按需加载</strong></p>
<h3 id="安装-react-app-rewired-插件"><a href="#安装-react-app-rewired-插件" class="headerlink" title="安装 react-app-rewired 插件"></a>安装 react-app-rewired 插件</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> react-app-rewired customize-cra</span></span><br></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* package.json */</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">-   <span class="string">"start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line">+   <span class="string">"start"</span>: <span class="string">"react-app-rewired start"</span>,</span><br><span class="line">-   <span class="string">"build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line">+   <span class="string">"build"</span>: <span class="string">"react-app-rewired build"</span>,</span><br><span class="line">-   <span class="string">"test"</span>: <span class="string">"react-scripts test"</span>,</span><br><span class="line">+   <span class="string">"test"</span>: <span class="string">"react-app-rewired test"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在项目根目录创建一个 <code>config-overrides.js</code> 用于修改默认配置。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>.exports = function <span class="keyword">override</span>(<span class="built_in">config</span>, env) &#123;</span><br><span class="line">  <span class="comment">// do stuff with the webpack config...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">config</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>yarn start</code>命令运行之后报错：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Error: </span>Cannot find module 'react-scripts/package.json'</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong>：缺少react-scripts插件<br><strong>解决方案</strong>：安装 react-scripts 插件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save react-scripts</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/2020/04/10/%E6%80%BB%E7%BB%93%E5%87%A0%E4%B8%AA%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<p>总结ES6中的promise的用法，以及相关的概念。</p>
<a id="more"></a>

<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>promise</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6（二）</title>
    <url>/2020/04/07/ES6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>接着复习一下ES6,总结来自<a href="https://www.runoob.com/w3cnote/es6-string.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<a id="more"></a> 

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串的识别"><a href="#字符串的识别" class="headerlink" title="字符串的识别"></a>字符串的识别</h3><p>ES6以前的识别方法是 indexOf() 或者 lastIndexOf(),返回参数对应的索引值。<br>ES6新增以下方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">includes</span><span class="params">()</span></span>:返回布尔值，判断是否找到参数字符串</span><br><span class="line"><span class="function"><span class="title">startWith</span><span class="params">()</span></span>:返回布尔值，判断参数字符串是否在原字符串的头部</span><br><span class="line"><span class="function"><span class="title">endWith</span><span class="params">()</span></span>:返回布尔值，判断参数字符串是否在原字符串的尾部</span><br></pre></td></tr></table></figure>
<p>以上三个方法都可以接受两个参数：需要搜索的字符串，可选的搜素起始位置索引（不包括索引）<br>注意点：<br>    这三个方法只返回布尔值。<br>    这三个方法如果传入了正则表达式，会抛出错误。indexOf会将正则表达式转化为字符串并且搜索</p>
<h3 id="字符串重复"><a href="#字符串重复" class="headerlink" title="字符串重复"></a>字符串重复</h3><p>repeat():返回新的字符串，表示将字符串重复指定次数返回。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">console.<span class="built-in">log</span>(<span class="string">'hello,'</span>.<span class="keyword">repeat</span>(<span class="number">2</span>))</span><br><span class="line"><span class="comment">//hello,hello,</span></span><br></pre></td></tr></table></figure>
<p>如果参数是小数，则会<strong>向下取整</strong></p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">console.<span class="built-in">log</span>(<span class="string">'hello,'</span>.<span class="keyword">repeat</span>(<span class="number">3.2</span>))</span><br><span class="line"><span class="comment">//hello,hello,hello,</span></span><br></pre></td></tr></table></figure>
<p>如果参数是0至-1，则取0,<strong>返回空的字符串</strong><br>如果参数是NaN,也视为repeat零次，<strong>返回空的字符串</strong><br>如果参数是负数或infinity，会报错</p>
<h3 id="字符串补齐"><a href="#字符串补齐" class="headerlink" title="字符串补齐"></a>字符串补齐</h3><p>padStart:返回新的字符串，表示用参数字符串从头部补齐<br>padEnd:返回新的字符串，表示参数字符串从尾部补齐<br>以上两个方法都接受两个参数，第一个参数是生成字符串的最小长度，第二个参数是指定生成的字符串。如果没有指定第二个参数，默认用空格填充</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">"h"</span>.padStart(<span class="number">5</span>,<span class="string">"o"</span>));  <span class="comment">// "ooooh"</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"h"</span>.padEnd(<span class="number">5</span>,<span class="string">"o"</span>));    <span class="comment">// "hoooo"</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"h"</span>.padStart(<span class="number">5</span>));      <span class="comment">// "    h"</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>如果指定的长度小于或者等于原字符串的长度，则返回原字符串<br>如果原字符串加上补全的字符串长度大于指定长度，则截去超出位数的<strong>补全字符串</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">"hello"</span>.padEnd(<span class="number">10</span>,<span class="string">",world!"</span>));  <span class="comment">// "hello,worl"</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"hello"</span>.padStart(<span class="number">10</span>,<span class="string">",world!"</span>));  <span class="comment">// ",worlhello"</span></span><br></pre></td></tr></table></figure>
<p><strong>常用于补全位数</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">"123"</span>.padStart(<span class="number">10</span>,<span class="string">"0"</span>));  <span class="comment">// "0000000123"</span></span><br></pre></td></tr></table></figure>

<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串相当于加强版的字符串，用反引号 `,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>普通字符串</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">string</span> = <span class="string">`Hello'\n'world`</span>;</span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">string</span>); </span><br><span class="line"><span class="comment">// "Hello'</span></span><br><span class="line"><span class="comment">// 'world"</span></span><br></pre></td></tr></table></figure>
<p>多行字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 =  <span class="string">`Hey,</span></span><br><span class="line"><span class="string">can you stop angry now?`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string1);</span><br><span class="line"><span class="comment">// Hey,</span></span><br><span class="line"><span class="comment">// can you stop angry now?</span></span><br></pre></td></tr></table></figure>
<p>字符串插入变量和表达式。<br>变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">let <span class="type">name</span> = "Mike";</span><br><span class="line">let age = <span class="number">27</span>;</span><br><span class="line">let <span class="keyword">info</span> = `My <span class="type">Name</span> <span class="keyword">is</span> $&#123;<span class="type">name</span>&#125;,I am $&#123;age+<span class="number">1</span>&#125; years <span class="built_in">old</span> next year.`</span><br><span class="line">console.log(<span class="keyword">info</span>);</span><br><span class="line">// My <span class="type">Name</span> <span class="keyword">is</span> Mike,I am <span class="number">28</span> years <span class="built_in">old</span> next year.</span><br></pre></td></tr></table></figure>
<p>字符串中调用函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"have fun!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2= <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2);  <span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>模板字符串会保留空格</p>
<h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>标签模板，是一个函数的调用，其中调用的参数是模板字符串。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`Hello world!`</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">alert(<span class="string">'Hello world!'</span>);</span><br></pre></td></tr></table></figure>
<p>当模板字符串中带有变量，会将模板字符串参数处理成多个参数。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(stringArr,<span class="rest_arg">...values</span>)</span></span>&#123;</span><br><span class="line"> let result = <span class="string">""</span>;</span><br><span class="line"> <span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;stringArr.length;i++)&#123;</span><br><span class="line">  result += stringArr[i];</span><br><span class="line">  <span class="keyword">if</span>(values[i])&#123;</span><br><span class="line">   result += values[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">let name = <span class="string">'Mike'</span>;</span><br><span class="line">let age = <span class="number">27</span>;</span><br><span class="line">f`My Name <span class="keyword">is</span> $&#123;name&#125;,I am $&#123;age+<span class="number">1</span>&#125; years old next year.`;</span><br><span class="line"><span class="comment">// "My Name is Mike,I am 28 years old next year."</span></span><br><span class="line"> </span><br><span class="line">f`My Name <span class="keyword">is</span> $&#123;name&#125;,I am $&#123;age+<span class="number">1</span>&#125; years old next year.`;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">f([<span class="string">'My Name is'</span>,<span class="string">',I am '</span>,<span class="string">' years old next year.'</span>],<span class="string">'Mike'</span>,<span class="number">28</span>);</span><br></pre></td></tr></table></figure>
<p><strong>应用</strong><br>过滤 HTML 字符串，防止用户输入恶意内容。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(stringArr,<span class="rest_arg">...values</span>)</span></span>&#123;</span><br><span class="line"> let result = <span class="string">""</span>;</span><br><span class="line"> <span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;stringArr.length;i++)&#123;</span><br><span class="line">  result += stringArr[i];</span><br><span class="line">   <span class="keyword">if</span>(values[i])&#123;</span><br><span class="line">     result += String(values[i]).replace(/&amp;/g, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">               .replace(/&lt;/g, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">               .replace(/&gt;/g, <span class="string">"&amp;gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">name = <span class="string">'&lt;Amy&amp;MIke&gt;'</span>;</span><br><span class="line">f`&lt;p&gt;Hi, $&#123;name&#125;.I would like send you some message.&lt;/p&gt;`;</span><br><span class="line"><span class="comment">// &lt;p&gt;Hi, &amp;lt;Amy&amp;amp;MIke&amp;gt;.I would like send you some message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo从零开始搭建博客</title>
    <url>/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>&emsp;&emsp;之前做了一个个人主页，但是由于部署在github，导致国内网打开很慢的原因，因此上网搜索了一些解决的办法。看到很多搭建博客的方法，索性不如也把自己的博客搭建起来，于是乎，特此写一篇笔记记录一下心得以及踩过的大部分坑吧~</p>
<a id="more"></a> 

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>打开<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>下载安装node.js<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/1.png" alt></p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>打开<a href="https://git-scm.com/download" target="_blank" rel="noopener">Git官网</a>,选择下载对应版本安装<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/2.png" alt></p>
<h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>由于npm的服务器位于国外可能影响安装，为了提高下载速度，我们来安装一个cnpm<br><code>npm install cnpm -g --registry=https://registry.npm.taobao.org</code></p>
<h3 id="全局安装hexo"><a href="#全局安装hexo" class="headerlink" title="全局安装hexo"></a>全局安装hexo</h3><p><code>cnpm install -g hexo</code></p>
<h2 id="搭建一个博客"><a href="#搭建一个博客" class="headerlink" title="搭建一个博客"></a>搭建一个博客</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>输入<code>hexo init</code>初始化项目<br>然后会出现这样一个目录<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/3.png" alt></p>
<h3 id="打包成静态文件"><a href="#打包成静态文件" class="headerlink" title="打包成静态文件"></a>打包成静态文件</h3><p>输入<code>hexo g</code>会将文件编译为静态文件，md格式会编译为html<br>此时文件中会多出一个<code>public</code>文件夹</p>
<h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p>输入<code>hexo s</code> 运行，在浏览器中输入 <code>http://localhost:4000</code><br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4.png" alt></p>
<h2 id="部署到码云"><a href="#部署到码云" class="headerlink" title="部署到码云"></a>部署到码云</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>进入<a href="https://gitee.com/" target="_blank" rel="noopener">码云官网</a>，登录账号，创建一个仓库，注意仓库路径必须是<code>&lt;user-name&gt;.github.io</code>,<code>&lt;user-name&gt;</code>是自己的用户名<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/5.png" alt><br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/6.png" alt></p>
<h3 id="连接仓库"><a href="#连接仓库" class="headerlink" title="连接仓库"></a>连接仓库</h3><p>点击仓库旁的 克隆下载，复制https地址<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7.png" alt><br>然后打开blog文件夹中的<code>_config.yml</code>文件（项目配置文件），搜索<code>deploy</code><br>将repo:后面的网址改成你复制的地址，保存。<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/8.png" alt></p>
<h3 id="推送到仓库"><a href="#推送到仓库" class="headerlink" title="推送到仓库"></a>推送到仓库</h3><p>安装<code>hexo-deployer-git</code>模块，gitbash 运行 <code>cnpm install hexo-deployer-git --save</code></p>
<p>安装好之后，文件夹会多出来一个.deploy_git,然后运行命令 <code>hexo g -d</code>,就可以把内容推送到码云了。</p>
<h3 id="开启码云Page服务"><a href="#开启码云Page服务" class="headerlink" title="开启码云Page服务"></a>开启码云Page服务</h3><p>点击仓库右上角的服务，然后点击Gitee Pages<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/9.png" alt><br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/10.png" alt><br>注意，以后每次提交至gitee后都要来手动更新哦~~也可以花钱购买自动部署服务</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>写给自己的话</title>
    <url>/2020/04/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>&emsp;&emsp;每天都是新的开始，做好准备，才能迎接更好的未来。</p>
<a id="more"></a> 

<h3 id="不安"><a href="#不安" class="headerlink" title="不安"></a>不安</h3><p>临近毕业，很多事情不断的涌进脑海。<br>毕设，工作，父母，建筑，学习……<br>仿佛人生到了一个转折点，不再是一个无忧无虑的时刻了。今后的日子应该如何，选择很重要。</p>
<h3 id="建筑-VS-前端"><a href="#建筑-VS-前端" class="headerlink" title="建筑 VS 前端"></a>建筑 VS 前端</h3><p>和朋友聊聊天，说到转行的不易，有多少份简历石沉大海，就有多少次怀疑直击内心。<br>要不要先找到一份建筑的工作让自己安下这颗不稳定的心，以及要不要放手一搏不留退路。</p>
<h3 id="我的选择"><a href="#我的选择" class="headerlink" title="我的选择"></a>我的选择</h3><p>我想要选择放手一搏，既然心是向往的，就不要给自己一个松懈的借口。身边有支持着你的人，如果就这样选择放弃了，回过头，好像都是些可笑的回忆。</p>
<h4 id="心之所及，就是远方"><a href="#心之所及，就是远方" class="headerlink" title="心之所及，就是远方"></a>心之所及，就是远方</h4><p>不抛弃，不放弃，好好做好每一件事，相信自己，就一定可以的！加油！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
