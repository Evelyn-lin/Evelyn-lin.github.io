<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>重新认识Ajax</title>
    <url>/2020/04/10/AJAX%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结Ajax的用法，以及相关的概念。</p>
<a id="more"></a>

<h3 id="一、Ajax的由来"><a href="#一、Ajax的由来" class="headerlink" title="一、Ajax的由来"></a>一、Ajax的由来</h3><p>在了解Ajax由来之前，先从一个小案例说起。上网浏览的页面都是浏览器先服务端发起请求，服务端得到请求之后，读取并处理数据返回给客户端并且呈现出来。一个请求对应一个页面，传统的页面交互功能，也是通过请求回执的信息去更新一个页面。</p>
<p>如果在庞大的页面中，只需要更新一小块内容，但是每次都必须更新一个页面，是不是过于浪费呢？<br>以及，在请求过程中，页面的等待时间过长也会带来不好的体验，因此想要进行局部更新，并且不会产生等待页面，即不会阻塞后面代码的运行，就产生了Ajax，通过<strong>异步</strong>方式发出请求，并实现页面的<strong>局部更新</strong>。也就是Ajax的由来以及最主要的用法。</p>
<p>Ajax的核心是XMLHttpRequest（简称XHR），XHR为浏览器<strong>发送请求</strong>和<strong>解析服务器响应</strong>提供了流畅的接口。现在的浏览器基本都支持原生的XHR对象。</p>
<h3 id="二、原生js实现ajax"><a href="#二、原生js实现ajax" class="headerlink" title="二、原生js实现ajax"></a>二、原生js实现ajax</h3><p>总结来自 W3school <a href="https://www.w3school.com.cn/ajax/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/ajax/index.asp</a></p>
<p><strong>创建XMLHttpRequest对象</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (window.XMLHttpRequest)&#123;</span><br><span class="line">    <span class="comment">//IE7+,Firefox,Chrome,Opera,Safari</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// IE6,IE5浏览器执行代码</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> <span class="type">ActiveXObject</span>(<span class="string">"Microsoft.XMLHTTP"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向服务器发送请求</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">xmlhtttp.<span class="keyword">open</span>(<span class="keyword">method</span>, url , async); </span><br><span class="line"><span class="comment">//method：请求的类型；GET 或 POST</span></span><br><span class="line"><span class="comment">//method：请求的类型；GET 或 POST</span></span><br><span class="line"><span class="comment">//async：true（异步）或 false（同步）</span></span><br><span class="line">xmlhttp.send(<span class="built_in">string</span>)  <span class="comment">//string仅用于post请求</span></span><br><span class="line"></span><br><span class="line">get请求：</span><br><span class="line">xmlhttp.<span class="keyword">open</span>(<span class="string">"GET"</span>, <span class="string">"/try/ajax/demo_get.php?t="</span> + <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>random<span class="literal">()</span>, <span class="literal">true</span>);</span><br><span class="line">xmlhttp.send<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">post请求：</span><br><span class="line">xmlhttp.<span class="keyword">open</span>(<span class="string">"POST"</span>,<span class="string">"/try/ajax/demo_post2.php"</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//使用 setRequestHeader() 来添加 HTTP 头;</span></span><br><span class="line">xmlhttp.set<span class="constructor">RequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>)</span>;</span><br><span class="line">xmlhttp.send(<span class="string">"fname=Henry&amp;lname=Ford"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>服务器响应</strong><br>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>responseText</td>
<td>获得字符串式的响应数据</td>
</tr>
<tr>
<td>responseXML</td>
<td>获得XML形式的响应数据</td>
</tr>
</tbody></table>
<p>responseText 属性</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">document.getElementById(<span class="string">"myDiv"</span>).<span class="attribute">innerHTML</span>=xmlhttp.responseText;</span><br></pre></td></tr></table></figure>
<p>responseXML 属性</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">xmlDoc</span>=xmlhttp.responseXML;</span><br><span class="line"><span class="attribute">txt</span>=<span class="string">""</span>;</span><br><span class="line"><span class="attribute">x</span>=xmlDoc.getElementsByTagName("ARTIST");</span><br><span class="line"><span class="keyword">for</span> (<span class="attribute">i</span>=0;i&lt;x.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">txt</span>=txt + x[i].childNodes[0].nodeValue + <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(<span class="string">"myDiv"</span>).<span class="attribute">innerHTML</span>=txt;</span><br></pre></td></tr></table></figure>
<p><strong>onreadystatechange 事件</strong><br>当请求被发送到服务器时，我们需要执行一些基于响应的任务。<br>每当 readyState 改变时，就会触发 onreadystatechange 事件。</p>
<table>
    <tr>
        <th> 属性 </th>
        <th> 描述 </th>
    </tr>
    <tr>
        <td> onreadystatechange </td>
        <td> 存储函数或函数名，每当readyState变化shift，就会触发函数 </td>
    </tr>
     <tr>
        <td> readyState </td>
        <td> 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。
            <ul>
                <li> 0: 请求未初始化 </li>
                <li> 1: 服务器连接已建立 </li>
                <li> 2: 请求已接收 </li>
                <li> 3: 请求处理中 </li>
                <li> 4: 请求已完成，且响应已就绪 </li>
            </ul>
         </td>
    </tr>
    <tr>
        <td> status </td>
        <td> 200: "OK" <br>
            404: 未找到页面 </td>
    </tr>
</table>
在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。
当 readyState 等于 4 且状态为 200 时，表示响应已就绪：
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">xmlhttp.<span class="attribute">onreadystatechange</span>=function()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.<span class="attribute">readyState</span>==4 &amp;&amp; xmlhttp.<span class="attribute">status</span>==200)</span><br><span class="line">    &#123;</span><br><span class="line">        document.getElementById(<span class="string">"myDiv"</span>).<span class="attribute">innerHTML</span>=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、封装一个ajax吧"><a href="#三、封装一个ajax吧" class="headerlink" title="三、封装一个ajax吧"></a>三、封装一个ajax吧</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> obj2str(data)&#123;</span><br><span class="line">    data = data<span class="operator"> || </span>&#123;&#125;;<span class="comment">// 如果没有传参, 为了添加随机因子,必须自己创建一个对象</span></span><br><span class="line">    data.t = <span class="keyword">new</span> <span class="constructor">Date()</span>.get<span class="constructor">Time()</span>;</span><br><span class="line">    var res = <span class="literal">[]</span>;</span><br><span class="line">    for (var key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        res.push(encode<span class="constructor">URLComponent(<span class="params">key</span>)</span> + <span class="string">"="</span> encode<span class="constructor">URLComponent(<span class="params">data</span>[<span class="params">key</span>])</span>);<span class="comment">//中文转码</span></span><br><span class="line">    &#125;</span><br><span class="line">    return res.join(<span class="string">"&amp;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> ajax(options)&#123;</span><br><span class="line">    <span class="comment">//创建一个XMLHttpRequest对象</span></span><br><span class="line">    var xmlhttp,timer;</span><br><span class="line">    <span class="keyword">if</span> (window.XMLHttpRequest) &#123;</span><br><span class="line">        xmlhttp = <span class="keyword">new</span> <span class="constructor">XMLHttpRequest()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xml = <span class="keyword">new</span> <span class="constructor">ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求</span></span><br><span class="line">    <span class="keyword">let</span> str = onj2str(options.data);</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="keyword">type</span>.<span class="keyword">to</span><span class="constructor">LowerCase()</span><span class="operator"> === </span><span class="string">"get"</span>) &#123;</span><br><span class="line">        xmlhttp.<span class="keyword">open</span>(<span class="string">"GET"</span>, options.url + <span class="string">"?"</span> + str, <span class="literal">true</span>);</span><br><span class="line">        xmlhttp.send<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xmlhttp.<span class="keyword">open</span>(<span class="string">"POST"</span>, options.url, <span class="literal">true</span>);</span><br><span class="line">        xmlhttp.set<span class="constructor">RequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>)</span>;</span><br><span class="line">        xmlhttp.send(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//响应</span></span><br><span class="line">    xmlhttp.onreadystatechange = <span class="keyword">function</span> (ev2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState<span class="operator"> === </span><span class="number">4</span>)&#123;</span><br><span class="line">            clear<span class="constructor">Interval(<span class="params">timer</span>)</span>;</span><br><span class="line">            <span class="comment">//判断是否请求成功(Http状态码大于等于200，且小于300，和状态码等于304为请求成功)</span></span><br><span class="line">            <span class="keyword">if</span> (xmlhttp.status &gt;= <span class="number">200</span><span class="operator"> &amp;&amp; </span>xmlhttp.status &lt; <span class="number">300</span><span class="operator"> || </span>xmlhttp.status<span class="operator"> === </span><span class="number">304</span>) &#123;</span><br><span class="line">                option.success(xmlhttp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                option.error(xmlhttp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (option.timeout)&#123;</span><br><span class="line">        timer = set<span class="constructor">Interval(<span class="params">function</span> ()</span> &#123;</span><br><span class="line">            console.log(<span class="string">"中断请求"</span>);</span><br><span class="line">            xmlhttp.abort<span class="literal">()</span>;</span><br><span class="line">            clear<span class="constructor">Interval(<span class="params">timer</span>)</span>;</span><br><span class="line">        &#125;,option.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS之我的知识盲区系列（一）</title>
    <url>/2020/04/08/CSS%E4%B9%8B%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>记录关于CSS的遗忘知识点。</p>
<a id="more"></a>

<h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>转自阮一峰老师: <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>采用Flex布局的元素，称为Flex容器，它的所有子元素自动称为容器成员，称为flex项目（flex item）</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png" alt="img"></p>
<h4 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h4><p> flex-direction     定义主轴的方向，即项目排列的方向。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">row</span>：默认值，主轴为水平方向，从左到右</span><br><span class="line"><span class="keyword">row</span>-<span class="keyword">reverse</span>:主轴为水平方向，从右到左</span><br><span class="line"><span class="keyword">column</span>:主轴为垂直方向，从上到下</span><br><span class="line"><span class="keyword">column</span>-<span class="keyword">reverse</span>：主轴为垂直方向，从下到上</span><br></pre></td></tr></table></figure>
<p> flex-wrap   定义换行</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">nowrap: 默认值，不换行</span><br><span class="line"><span class="built_in">wrap</span>：换行，第一行在上方</span><br><span class="line"><span class="built_in">wrap</span>-<span class="built_in">reverse</span>：换行，第一行在下方</span><br></pre></td></tr></table></figure>
<p> flex-flow  是flex-direction和flex-wrap的简写形式</p>
<p>   默认row nowrap；</p>
<p> justify-content  定义项目在主轴上的对齐方式</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">flex-start  对齐开始的一端</span><br><span class="line">flex-<span class="keyword">end</span>   对齐结束的一端</span><br><span class="line">center   居中对齐</span><br><span class="line"><span class="literal">space</span>-<span class="keyword">between</span>  两端对齐</span><br><span class="line"><span class="literal">space</span>-<span class="keyword">around</span>   每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure>
<p> align-items  定义项目在交叉轴上如何对齐</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">flex-<span class="built_in">start</span></span><br><span class="line">flex-<span class="keyword">end</span></span><br><span class="line">center</span><br><span class="line">stretch默认值：如果<span class="keyword">item</span>未设置交叉轴上的高度/宽度，将沾满整个容器的高/宽</span><br><span class="line">baseline：项目的第一行文字的基线对齐</span><br></pre></td></tr></table></figure>
<p> align-content  定义多根轴线的对齐方式</p>
<p>  <img src="https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png" alt="img"></p>
<h4 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">order</span> 定义项目的排列顺序  数值越小，排列越靠前</span><br><span class="line"><span class="attribute">flex-grow</span>  定义项目的放大比例，默认为0，如果所有项目都有此属性，则会按比例放大</span><br><span class="line"><span class="attribute">flex-shrink</span> 定义项目的缩小比例，默认为1.</span><br><span class="line">如果所有项目比例为1，一个为0；那么空间不足时，为0的不会缩小，其他的会缩小。</span><br><span class="line"><span class="attribute">flex-basis</span>  定义在分配多余空间之前，项目占据的主轴空间，默认是<span class="attribute">auto</span>，即项目本来大小</span><br><span class="line"><span class="attribute">flex</span>  是<span class="attribute">flex-grow</span>，<span class="attribute">flex-shrink</span>，<span class="attribute">flex-basis</span>的简写，默认是0 1 <span class="attribute">auto</span></span><br><span class="line"><span class="attribute">align-self</span>  允许单个项目有与其他项目不一样的对齐方式，可覆盖alignitems属性</span><br></pre></td></tr></table></figure>

<h2 id="隐藏滚动条"><a href="#隐藏滚动条" class="headerlink" title="隐藏滚动条"></a>隐藏滚动条</h2><p>原本的内容超出盒子的大小，给盒子设置overflow-y:scroll;              overflow-x:hidden;<br>可以在盒子外面再包裹一个div盒子，给这个盒子设置同样的宽高，然后设置overflow:hidden即可。这样子盒子的滚动条被隐藏，但是滚动条依然还在的奥。</p>
<p> overflow属性    overflow-x   overflow-y</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">visible：默认值，超出的内容不会被修剪，会出现在元素框外</span><br><span class="line">hidden：超出的部分会被修剪</span><br><span class="line">scroll：内容会被修剪，但是在宽的旁边会生成一个滚动条</span><br><span class="line"><span class="attribute">auto</span>：内容如果被修剪，就会出现滚动条</span><br><span class="line"><span class="attribute">inherit</span>：继承父元素属性值</span><br></pre></td></tr></table></figure>


<h2 id="borderimage属性"><a href="#borderimage属性" class="headerlink" title="borderimage属性"></a>borderimage属性</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">border</span>-<span class="built_in">image</span>(URL)</span><br><span class="line">  <span class="built_in">border</span>-<span class="built_in">image</span>-slice:裁剪位置 ，单位px</span><br><span class="line">  <span class="built_in">border</span>-<span class="built_in">image</span>-repeat:重复性</span><br><span class="line">    stretch  默认值，拉伸</span><br><span class="line">    <span class="built_in">round</span>  平铺</span><br><span class="line">    none不重复</span><br><span class="line">    repeat  重复</span><br></pre></td></tr></table></figure>
<h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>  定义动画<br>  <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">@keyframes</span> name&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">animation</span>:name <span class="number">2s</span> linear infinite;</span><br></pre></td></tr></table></figure></p>
<h2 id="3d效果"><a href="#3d效果" class="headerlink" title="3d效果"></a>3d效果</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">需要为元素添加 </span><br><span class="line"><span class="attribute">transform-style</span>:preserve-<span class="number">3</span>d;</span><br><span class="line">父元素添加</span><br><span class="line"><span class="attribute">perspective</span>:<span class="number">2000px</span>;</span><br></pre></td></tr></table></figure>
<h2 id="重排-和-重绘"><a href="#重排-和-重绘" class="headerlink" title="重排 和 重绘"></a>重排 和 重绘</h2><p> <strong>重排</strong><br>   DOM的变化影响到元素的属性变化，例如宽高，浏览器重新计算元素的几何属性，其他元素的几何属性也会受到影响，浏览器需要重新构建渲染树<br> <strong>重绘</strong><br>   浏览器将受到影响的部分重新绘制在屏幕上。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6（二）</title>
    <url>/2020/04/07/ES6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>接着复习一下ES6,总结来自<a href="https://www.runoob.com/w3cnote/es6-string.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<a id="more"></a> 

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串的识别"><a href="#字符串的识别" class="headerlink" title="字符串的识别"></a>字符串的识别</h3><p>ES6以前的识别方法是 indexOf() 或者 lastIndexOf(),返回参数对应的索引值。<br>ES6新增以下方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">includes</span><span class="params">()</span></span>:返回布尔值，判断是否找到参数字符串</span><br><span class="line"><span class="function"><span class="title">startWith</span><span class="params">()</span></span>:返回布尔值，判断参数字符串是否在原字符串的头部</span><br><span class="line"><span class="function"><span class="title">endWith</span><span class="params">()</span></span>:返回布尔值，判断参数字符串是否在原字符串的尾部</span><br></pre></td></tr></table></figure>
<p>以上三个方法都可以接受两个参数：需要搜索的字符串，可选的搜素起始位置索引（不包括索引）<br>注意点：<br>    这三个方法只返回布尔值。<br>    这三个方法如果传入了正则表达式，会抛出错误。indexOf会将正则表达式转化为字符串并且搜索</p>
<h3 id="字符串重复"><a href="#字符串重复" class="headerlink" title="字符串重复"></a>字符串重复</h3><p>repeat():返回新的字符串，表示将字符串重复指定次数返回。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">console.<span class="built-in">log</span>(<span class="string">'hello,'</span>.<span class="keyword">repeat</span>(<span class="number">2</span>))</span><br><span class="line"><span class="comment">//hello,hello,</span></span><br></pre></td></tr></table></figure>
<p>如果参数是小数，则会<strong>向下取整</strong></p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">console.<span class="built-in">log</span>(<span class="string">'hello,'</span>.<span class="keyword">repeat</span>(<span class="number">3.2</span>))</span><br><span class="line"><span class="comment">//hello,hello,hello,</span></span><br></pre></td></tr></table></figure>
<p>如果参数是0至-1，则取0,<strong>返回空的字符串</strong><br>如果参数是NaN,也视为repeat零次，<strong>返回空的字符串</strong><br>如果参数是负数或infinity，会报错</p>
<h3 id="字符串补齐"><a href="#字符串补齐" class="headerlink" title="字符串补齐"></a>字符串补齐</h3><p>padStart:返回新的字符串，表示用参数字符串从头部补齐<br>padEnd:返回新的字符串，表示参数字符串从尾部补齐<br>以上两个方法都接受两个参数，第一个参数是生成字符串的最小长度，第二个参数是指定生成的字符串。如果没有指定第二个参数，默认用空格填充</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">"h"</span>.padStart(<span class="number">5</span>,<span class="string">"o"</span>));  <span class="comment">// "ooooh"</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"h"</span>.padEnd(<span class="number">5</span>,<span class="string">"o"</span>));    <span class="comment">// "hoooo"</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"h"</span>.padStart(<span class="number">5</span>));      <span class="comment">// "    h"</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>如果指定的长度小于或者等于原字符串的长度，则返回原字符串<br>如果原字符串加上补全的字符串长度大于指定长度，则截去超出位数的<strong>补全字符串</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">"hello"</span>.padEnd(<span class="number">10</span>,<span class="string">",world!"</span>));  <span class="comment">// "hello,worl"</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"hello"</span>.padStart(<span class="number">10</span>,<span class="string">",world!"</span>));  <span class="comment">// ",worlhello"</span></span><br></pre></td></tr></table></figure>
<p><strong>常用于补全位数</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">"123"</span>.padStart(<span class="number">10</span>,<span class="string">"0"</span>));  <span class="comment">// "0000000123"</span></span><br></pre></td></tr></table></figure>

<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串相当于加强版的字符串，用反引号 `,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>普通字符串</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">string</span> = <span class="string">`Hello'\n'world`</span>;</span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">string</span>); </span><br><span class="line"><span class="comment">// "Hello'</span></span><br><span class="line"><span class="comment">// 'world"</span></span><br></pre></td></tr></table></figure>
<p>多行字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 =  <span class="string">`Hey,</span></span><br><span class="line"><span class="string">can you stop angry now?`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string1);</span><br><span class="line"><span class="comment">// Hey,</span></span><br><span class="line"><span class="comment">// can you stop angry now?</span></span><br></pre></td></tr></table></figure>
<p>字符串插入变量和表达式。<br>变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">let <span class="type">name</span> = "Mike";</span><br><span class="line">let age = <span class="number">27</span>;</span><br><span class="line">let <span class="keyword">info</span> = `My <span class="type">Name</span> <span class="keyword">is</span> $&#123;<span class="type">name</span>&#125;,I am $&#123;age+<span class="number">1</span>&#125; years <span class="built_in">old</span> next year.`</span><br><span class="line">console.log(<span class="keyword">info</span>);</span><br><span class="line">// My <span class="type">Name</span> <span class="keyword">is</span> Mike,I am <span class="number">28</span> years <span class="built_in">old</span> next year.</span><br></pre></td></tr></table></figure>
<p>字符串中调用函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"have fun!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2= <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2);  <span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>模板字符串会保留空格</p>
<h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>标签模板，是一个函数的调用，其中调用的参数是模板字符串。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`Hello world!`</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">alert(<span class="string">'Hello world!'</span>);</span><br></pre></td></tr></table></figure>
<p>当模板字符串中带有变量，会将模板字符串参数处理成多个参数。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(stringArr,<span class="rest_arg">...values</span>)</span></span>&#123;</span><br><span class="line"> let result = <span class="string">""</span>;</span><br><span class="line"> <span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;stringArr.length;i++)&#123;</span><br><span class="line">  result += stringArr[i];</span><br><span class="line">  <span class="keyword">if</span>(values[i])&#123;</span><br><span class="line">   result += values[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">let name = <span class="string">'Mike'</span>;</span><br><span class="line">let age = <span class="number">27</span>;</span><br><span class="line">f`My Name <span class="keyword">is</span> $&#123;name&#125;,I am $&#123;age+<span class="number">1</span>&#125; years old next year.`;</span><br><span class="line"><span class="comment">// "My Name is Mike,I am 28 years old next year."</span></span><br><span class="line"> </span><br><span class="line">f`My Name <span class="keyword">is</span> $&#123;name&#125;,I am $&#123;age+<span class="number">1</span>&#125; years old next year.`;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">f([<span class="string">'My Name is'</span>,<span class="string">',I am '</span>,<span class="string">' years old next year.'</span>],<span class="string">'Mike'</span>,<span class="number">28</span>);</span><br></pre></td></tr></table></figure>
<p><strong>应用</strong><br>过滤 HTML 字符串，防止用户输入恶意内容。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(stringArr,<span class="rest_arg">...values</span>)</span></span>&#123;</span><br><span class="line"> let result = <span class="string">""</span>;</span><br><span class="line"> <span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;stringArr.length;i++)&#123;</span><br><span class="line">  result += stringArr[i];</span><br><span class="line">   <span class="keyword">if</span>(values[i])&#123;</span><br><span class="line">     result += String(values[i]).replace(/&amp;/g, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">               .replace(/&lt;/g, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">               .replace(/&gt;/g, <span class="string">"&amp;gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">name = <span class="string">'&lt;Amy&amp;MIke&gt;'</span>;</span><br><span class="line">f`&lt;p&gt;Hi, $&#123;name&#125;.I would like send you some message.&lt;/p&gt;`;</span><br><span class="line"><span class="comment">// &lt;p&gt;Hi, &amp;lt;Amy&amp;amp;MIke&amp;gt;.I would like send you some message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS之我的知识盲区系列（二）</title>
    <url>/2020/04/09/CSS%E4%B9%8B%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>记录关于CSS的遗忘知识点。</p>
<a id="more"></a>

<h2 id="CSS文本"><a href="#CSS文本" class="headerlink" title="CSS文本"></a>CSS文本</h2><h3 id="装饰文字"><a href="#装饰文字" class="headerlink" title="装饰文字"></a>装饰文字</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">text-decoraton:underline; <span class="comment">//下划线</span></span><br><span class="line">text-decoraton:overline; <span class="comment">//上划线</span></span><br><span class="line">text-decoraton:overthrough; <span class="comment">//删除线</span></span><br><span class="line">text-decoraton:none; <span class="comment">//无</span></span><br></pre></td></tr></table></figure>
<h3 id="文字大小写转换"><a href="#文字大小写转换" class="headerlink" title="文字大小写转换"></a>文字大小写转换</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">text</span>-<span class="keyword">transform</span>:uppercase;</span><br><span class="line"><span class="type">text</span>-<span class="keyword">transform</span>:lowercase;</span><br><span class="line"><span class="type">text</span>-<span class="keyword">transform</span>:uppercase;</span><br></pre></td></tr></table></figure>
<h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-indent</span>:<span class="number">50px</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字符之间的空间"><a href="#字符之间的空间" class="headerlink" title="字符之间的空间"></a>字符之间的空间</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">letter-spacing</span>:<span class="number">5px</span>;</span><br><span class="line"><span class="attribute">letter-spacing</span>:-<span class="number">3px</span>;</span><br></pre></td></tr></table></figure>
<h3 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">line</span>-<span class="built_in">height</span>:<span class="number">30</span>px;</span><br></pre></td></tr></table></figure>
<h3 id="文字方向"><a href="#文字方向" class="headerlink" title="文字方向"></a>文字方向</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">direction</span>:rtl;  <span class="comment">//right to left</span></span><br><span class="line"><span class="attribute">direction</span>:ltr;  <span class="comment">//left to right</span></span><br></pre></td></tr></table></figure>
<p><strong>注意后者，如果结尾有标点符号，会移动至最左边奥~因为开头不能有标点吧！</strong></p>
<h3 id="禁用文字换行"><a href="#禁用文字换行" class="headerlink" title="禁用文字换行"></a>禁用文字换行</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">white-<span class="literal">space</span>:nowrap</span><br></pre></td></tr></table></figure>
<h3 id="位于同一行的文字与图片的居中对齐"><a href="#位于同一行的文字与图片的居中对齐" class="headerlink" title="位于同一行的文字与图片的居中对齐"></a>位于同一行的文字与图片的居中对齐</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">vertical-align:<span class="keyword">middle</span></span><br></pre></td></tr></table></figure>
<h2 id="CSS文字"><a href="#CSS文字" class="headerlink" title="CSS文字"></a>CSS文字</h2><h3 id="文字异体"><a href="#文字异体" class="headerlink" title="文字异体"></a>文字异体</h3><p>将小写字母转为小型的大写</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-variant</span>:small-caps</span><br><span class="line">&lt;<span class="selector-tag">span</span> style=<span class="string">"font-variant:small-caps"</span>&gt;Small&lt;/span&gt; <span class="comment">//效果如下所示</span></span><br></pre></td></tr></table></figure>
<p><span style="font-variant:small-caps">Small</span></p>
<h2 id="CSS列表"><a href="#CSS列表" class="headerlink" title="CSS列表"></a>CSS列表</h2><h3 id="列表的标记类型"><a href="#列表的标记类型" class="headerlink" title="列表的标记类型"></a>列表的标记类型</h3><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">list</span>-style-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>具体样式可查阅 <a href="https://www.runoob.com/cssref/pr-list-style-type.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<h3 id="自定义标记类型"><a href="#自定义标记类型" class="headerlink" title="自定义标记类型"></a>自定义标记类型</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">list-style-image</span><span class="selector-pseudo">:url()</span></span><br><span class="line"><span class="selector-tag">background-img</span><span class="selector-pseudo">:url()</span> 也可以实现</span><br><span class="line">使用伪元素：</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS表格"><a href="#CSS表格" class="headerlink" title="CSS表格"></a>CSS表格</h2><h3 id="标题位置"><a href="#标题位置" class="headerlink" title="标题位置"></a>标题位置</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">caption-side:<span class="built_in">bottom</span>/<span class="built_in">top</span>/inherit</span><br></pre></td></tr></table></figure>
<h2 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h2><h3 id="裁剪图片"><a href="#裁剪图片" class="headerlink" title="裁剪图片"></a>裁剪图片</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">img </span><br><span class="line">&#123;</span><br><span class="line">position:absolute;  <span class="comment">//必须设置绝对定位</span></span><br><span class="line">clip:rect(<span class="number">0</span>px,<span class="number">60</span>px,<span class="number">200</span>px,<span class="number">0</span>px); <span class="comment">//四个值表示：上右下左裁剪线</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript继承的理解</title>
    <url>/2020/04/12/JavaScript%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h3><p>通过某种方式让一个对象可以访问到另一个对象中的属性和方法，我们把这种方式称之为继承。</p>
<a id="more"></a>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span></span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    sayHi: <span class="type">funtion</span>() &#123;</span><br><span class="line">        console.log(<span class="string">'Hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Father是一个构造函数，通过 new 关键词可以创建Father实例</span></span><br><span class="line"><span class="keyword">var</span> father1 = <span class="keyword">new</span> <span class="type">Father</span>();实例会拥有构造函数的方法和属性；</span><br><span class="line"><span class="keyword">var</span> father2 = <span class="keyword">new</span> <span class="type">Father</span>();同样也有name属性和sayHi方法；</span><br><span class="line"><span class="comment">//每创建一个实例，就会给这个实例添加构造函数的属性和方法，但是每个实例的属性和方法是不可复用的；</span></span><br><span class="line"><span class="comment">//借助原型链，原型上的属性和方法是共享的。</span></span><br><span class="line">Father.prototype.age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span><span class="params">(<span class="keyword">name</span>)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    this.name = name;</span></span></span><br><span class="line"><span class="function"><span class="comment">    sayHi: funtion() &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        console.log('Hi')</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">Son</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">Son</span>.<span class="title">prototype</span> = <span class="title">new</span> <span class="title">Father</span><span class="params">()</span>;</span><span class="comment">//此时构造函数是变成了Father</span></span><br><span class="line">Son.peototype<span class="function">.<span class="keyword">constructor</span> = <span class="title">Son</span>;</span><span class="comment">//修正构造函数</span></span><br></pre></td></tr></table></figure>
<p>要点：将子类的原型指向父类的实例，这样子类的实例在访问原型的时候回提供一个指向父类原型的指针。实现继承父类的属性和方法。<br>缺点:1.包含引用类型值的原型属性会被所有实例共享，这会导致对一个实例的修改会影响另一个实例。<br>     2.创建子类实例时，不能像父类传递参数</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    sayHi: funtion() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,argus)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点:在子类中使用call/apply方法，改变this的指向。<br>缺点：1.每次创建子类实例时，都会在函数中添加属性和方法；无法实现函数复用<br>      2.在父类原型中定义的方法，子类无法继承。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span><span class="params">(<span class="keyword">name</span>)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    this.name = name;</span></span></span><br><span class="line"><span class="function"><span class="comment">    sayHi: funtion() &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        console.log('Hi')</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">Son</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    Father.call(this,argus)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">Son</span>.<span class="title">prototype</span> = <span class="title">new</span> <span class="title">Father</span><span class="params">()</span>;</span><span class="comment">//此时构造函数是变成了Father</span></span><br><span class="line">Son.peototype<span class="function">.<span class="keyword">constructor</span> = <span class="title">Son</span>;</span><span class="comment">//修正构造函数</span></span><br></pre></td></tr></table></figure>
<p>要点：其实就是以上两种方法的结合，既能向父类传递参数，又能够继承原型上的方法。</p>
<h3 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">//实现一</span><br><span class="line">var source=&#123;<span class="keyword">name</span>:<span class="string">"李白"</span>,age:<span class="number">15</span>&#125;</span><br><span class="line">    var <span class="keyword">target</span>=&#123;&#125;;</span><br><span class="line">    <span class="keyword">target</span>.<span class="keyword">name</span>=source.<span class="keyword">name</span></span><br><span class="line">    <span class="keyword">target</span>.age=source.age;</span><br><span class="line"></span><br><span class="line">//实现二</span><br><span class="line"> <span class="function"><span class="keyword">function</span></span> extend(<span class="keyword">target</span>,source)&#123;</span><br><span class="line">        for(key <span class="keyword">in</span> source)&#123;</span><br><span class="line">            <span class="keyword">target</span>[key]=source[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    extend(<span class="keyword">target</span>,source)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6（一）</title>
    <url>/2020/04/05/ES6/</url>
    <content><![CDATA[<p>今天来复习一下ES6的相关知识吧，打好每一个基础吧。那么开始吧</p>
<a id="more"></a> 

<h2 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul>
<li><p>代码块内有效</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&#123;let a = <span class="number">0</span>; var b = <span class="number">2</span>&#125; a <span class="comment">// 报错 ReferenceError: a is not defined b // 2</span></span><br></pre></td></tr></table></figure>
<p>  在代码块内，let声明的是局部变量；var声明的是全局变量</p>
</li>
<li><p>不能重发声明</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let a = <span class="number">1</span>; let a = <span class="number">2</span>; var b = <span class="number">3</span>; var b = <span class="number">4</span>; a  <span class="comment">// Identifier 'a' has already been declared b  // 4</span></span><br></pre></td></tr></table></figure>
<p>for循环很适合用let，var声明的i是全局变量，因此外部的i等于最后一次i的值。<br>let声明的i在每轮循环中都是新的变量。</p>
</li>
<li><p>let不存在变量提升</p>
</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li><code>const</code>声明一个只读变量，声明之后不允许改变，一旦声明必须初始化，否则会报错</li>
<li>暂时性死区<ul>
<li><code>const</code>和<code>let</code>一样，都是局部作用域的，因此在声明之前使用变量会报错。</li>
</ul>
</li>
<li>注意：<code>const</code>声明之后允许改变。<ul>
<li>简单数据类型，就是值不许改变。</li>
<li>复杂数据类型，是指向数据的指针不发生改变，数据结构可以改变，所以复杂数据类型要慎用。</li>
</ul>
</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="解构模型"><a href="#解构模型" class="headerlink" title="解构模型"></a>解构模型</h3><ul>
<li>解构的源：右边部分</li>
<li>解构的目标：左边部分<h3 id="数组模型的解构（Array）"><a href="#数组模型的解构（Array）" class="headerlink" title="数组模型的解构（Array）"></a>数组模型的解构（Array）</h3></li>
<li>基本<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// a=1,b=2,c=3</span></span><br></pre></td></tr></table></figure></li>
<li>可嵌套<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">let[a,<span class="string">[[b]，c]]</span> = [<span class="number">1</span>,<span class="string">[[2],3]]</span>;</span><br><span class="line">// a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li>可忽略<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [a, ,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//a = 1; b = 3</span></span><br></pre></td></tr></table></figure></li>
<li>不完全解构<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">1</span>, b] = [ ];</span><br><span class="line">// <span class="attr">a</span> = <span class="number">1</span> ; <span class="attr">b</span> = undefined;</span><br></pre></td></tr></table></figure></li>
<li>剩余运算符<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// a = 1; b = [2, 3]</span></span><br></pre></td></tr></table></figure></li>
<li>字符串等<br>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现iterator接口的数据。<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="regexp">//</span>a = <span class="string">'h'</span>; b = <span class="string">'e'</span>; c = <span class="string">'l'</span>; d = <span class="string">'l'</span>; e = <span class="string">'o'</span></span><br></pre></td></tr></table></figure></li>
<li>解构默认值<br>当解构模式有匹配结果，且匹配结果是undefined时，会触发默认值作为返回结果。<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">1</span>] = [undefined]；</span><br><span class="line">//<span class="attr">a</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = a] = [];     // <span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = a] = [<span class="number">1</span>];    // <span class="attr">a</span> = <span class="number">1</span>, <span class="attr">b</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = a] = [<span class="number">1</span>, <span class="number">2</span>]; // <span class="attr">a</span> = <span class="number">1</span>, <span class="attr">b</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="对象模型的解构（Object）"><a href="#对象模型的解构（Object）" class="headerlink" title="对象模型的解构（Object）"></a>对象模型的解构（Object）</h3></li>
<li>基本<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> &#125;; <span class="regexp">//</span> foo = <span class="string">'aaa'</span> <span class="regexp">//</span> bar = <span class="string">'bbb'</span> </span><br><span class="line">let &#123; baz : foo &#125; = &#123; baz : <span class="string">'ddd'</span> &#125;; <span class="regexp">//</span> foo = <span class="string">'ddd'</span></span><br></pre></td></tr></table></figure></li>
<li>可嵌套可忽略<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">let obj = &#123;<span class="string">p:</span> [<span class="string">'hello'</span>, &#123;<span class="string">y:</span> <span class="string">'world'</span>&#125;] &#125;; let &#123;<span class="string">p:</span> [x, &#123; y &#125;] &#125; = obj; <span class="comment">// x = 'hello' // y = 'world' </span></span><br><span class="line">let obj = &#123;<span class="string">p:</span> [<span class="string">'hello'</span>, &#123;<span class="string">y:</span> <span class="string">'world'</span>&#125;] &#125;; let &#123;<span class="string">p:</span> [x, &#123;  &#125;] &#125; = obj; <span class="comment">// x = 'hello'</span></span><br></pre></td></tr></table></figure></li>
<li>不完全解构</li>
<li>剩余运算符</li>
<li>默认解构值</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ES6引入新的原始数据类型Symbol，表示独一无二的值，类似字符串，常用作对象的属性名。<br>允许添加一个参数，作为标识。参数相同值也不相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">"KK"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sy);    <span class="comment">//Symbol(KK)</span></span><br><span class="line"><span class="keyword">typeof</span>(sy);  <span class="comment">// symbol</span></span><br><span class="line">相同参数symbol() 返回的值不相等。</span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">"KK"</span>);</span><br><span class="line">sy === sy1;   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h3><p>由于每个Symbol的值都不相等，因此可以用作对象的属性名。以前都是用字符串。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sy</span> = Symbol(<span class="string">"key1"</span>);</span><br><span class="line"></span><br><span class="line">写法<span class="number">1</span>   </span><br><span class="line"><span class="keyword">let</span> <span class="attr">syObj</span> = &#123;&#125;;</span><br><span class="line">    syObj[sy] = <span class="string">"kk"</span>;</span><br><span class="line">    console.log(syObj);    </span><br><span class="line">    // &#123;Symbol(key1) : <span class="string">"kk"</span>&#125;</span><br><span class="line"></span><br><span class="line">写法二   </span><br><span class="line"><span class="keyword">let</span> <span class="attr">syObj</span> = &#123;</span><br><span class="line">  ​  [sy]: <span class="string">"kk"</span>                 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">写法三    </span><br><span class="line"><span class="keyword">let</span> <span class="attr">syObj</span> = &#123;</span><br><span class="line">  ​  Object.defineProperty(syObj,sy,&#123;value:<span class="string">"kk&#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意：Symbol作为对象属性名时不能用  <strong>.</strong> 运算符，要用 <strong>[]</strong>，因为.运算符后面跟字符串，取到的是字符串属性。</p>
<h3 id="如何访问Symbol作为属性名的属性"><a href="#如何访问Symbol作为属性名的属性" class="headerlink" title="如何访问Symbol作为属性名的属性"></a>如何访问Symbol作为属性名的属性</h3><p>不会出现在 for…in 、 for…of 的循环中，也不会被·<code>Object.keys() 、 Object.getOwnPropertyNames()</code>返回。如果要读取到一个对象的 Symbol 属性，可以通过<code>Object.getOwnPropertySymbols()</code>和 <code>Reflect.ownKeys()</code>取到。</p>
<h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h3><p>Symbol.for(),首先会在全局搜索被登记的Symbol中是否有该字符串参数作为名称的Symbol值，如果有即返回该Symbol值，如果没有就会创建一个Symbol值并登记。</p>
<h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h3><p>返回一个已登记的Symbol类型值的key，用来检测该字符串参数作为名称的Symbol值是否已被登记。</p>
<h2 id="Map与Set"><a href="#Map与Set" class="headerlink" title="Map与Set"></a>Map与Set</h2><h3 id="Map对象"><a href="#Map对象" class="headerlink" title="Map对象"></a>Map对象</h3><ul>
<li>Map对象与Object对象的异同<ul>
<li>都是由键值对组成的</li>
<li>Map的键可以是任意类型，Object的键只能是字符串或Symbol</li>
<li>Map中的键值是有序的，Object的不是</li>
<li>Map的键值对个数可以从size属性中获取，Object只能手动计算</li>
<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突</li>
</ul>
</li>
<li>增删改查<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();  <span class="comment">//创建</span></span><br><span class="line">myMap.<span class="keyword">set</span>(<span class="string">"string"</span>,<span class="string">"相关的值"</span>)  <span class="comment">//添加键值对</span></span><br><span class="line">myMap.<span class="keyword">get</span>(<span class="string">"string"</span>)  <span class="comment">//   获取对应key的值 </span></span><br><span class="line">myMap.has(<span class="string">"string"</span>)   <span class="comment">//是否存在key“string”  ：true</span></span><br><span class="line">myMap.delete(<span class="string">"string"</span>)  <span class="comment">//删除key“string”</span></span><br></pre></td></tr></table></figure></li>
<li>Map中的key<ul>
<li>字符串</li>
<li>对象  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var obj =&#123; &#125;; myMap.<span class="builtin-name">get</span>(obj) !== myMap.<span class="builtin-name">get</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>函数<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">fun</span> =<span class="title">function</span> <span class="params">()</span></span>&#123; &#125;; myMap.<span class="keyword">get</span>(<span class="function"><span class="keyword">fun</span>) !== myMap.<span class="title">get</span><span class="params">(function()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>NaN<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var myNaN= NaN; myMap.<span class="builtin-name">get</span>(myNaN) === myMap.<span class="builtin-name">get</span>(Number(<span class="string">"string"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Set对象"><a href="#Set对象" class="headerlink" title="Set对象"></a>Set对象</h3></li>
</ul>
</li>
<li>Set对象允许存储任何类型的唯一值 。</li>
<li>Set中的特殊值<ul>
<li>+0和-0是恒等的，所以不重复</li>
<li>undefined与undefined是恒等的，不重复</li>
<li>NaN与Nan是不恒等的，但在Set中只能存在一个</li>
</ul>
</li>
<li>Set设置与读取<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">let mySet = <span class="built_in">new</span> <span class="keyword">Set</span>();</span><br><span class="line">mySet.<span class="keyword">add</span>(<span class="number">1</span>);  //<span class="keyword">Set</span>(<span class="number">1</span>)&#123;<span class="number">1</span>&#125;</span><br><span class="line">mySet.<span class="keyword">delete</span>(<span class="number">1</span>) 删除</span><br></pre></td></tr></table></figure></li>
<li>应用<ul>
<li>数组去重<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var mySet = new Set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">[...mySet];  <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li>
<li>并集<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="keyword">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="keyword">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]); </span><br><span class="line"><span class="keyword">var</span> <span class="keyword">union</span> = <span class="keyword">new</span> <span class="keyword">Set</span>([...a, ...b]); <span class="comment">// &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>交集<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line">var b = <span class="keyword">new</span> <span class="constructor">Set([4, 3, 2])</span>; </span><br><span class="line">var intersect = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; <span class="params">b</span>.<span class="params">has</span>(<span class="params">x</span>)</span>)); <span class="comment">// &#123;2, 3&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>差集<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line">var b = <span class="keyword">new</span> <span class="constructor">Set([4, 3, 2])</span>; </span><br><span class="line">var difference = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; !<span class="params">b</span>.<span class="params">has</span>(<span class="params">x</span>)</span>)); <span class="comment">// &#123;1&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="正则表达式-regular-expression"><a href="#正则表达式-regular-expression" class="headerlink" title="正则表达式(regular expression)"></a>正则表达式(regular expression)</h2><p>使用场景：匹配（验证用户名、邮箱啊）、替换敏感词、提取文字啊。。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/</span>);</span><br><span class="line"><span class="keyword">var</span> rg1 = <span class="regexp">/abc/</span>;</span><br></pre></td></tr></table></figure>

<p>一共两种方式，正则表达式必须写在<code>/  /</code>之间。不需要用<code>&#39;   &#39;</code>将字符串包起来。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">rg.test(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<p>正则表达式<code>.test（检测内容）</code>    返回<code>ture</code>、<code>false</code></p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>就是指的特殊字符<br>/abc/只要有abc 连在一起就可以</p>
<h4 id="边界符"><a href="#边界符" class="headerlink" title="边界符^   $"></a>边界符^   $</h4><ul>
<li><p>^表示以。。。开头   /^abc/  必须以abc开头</p>
</li>
<li><p>$表示以。。。结尾   /abc$/  必须以abc结尾</p>
</li>
<li><p>^  $ 表示精确匹配     /^abc$/  必须是abc才是true</p>
<h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类[ ]"></a>字符类[ ]</h4></li>
<li><p><code>[ ]</code>表示只能多选一。或者的关系<br> <code>/[abc]/</code>  只要包含有a 或者 包含有 b 或者 包含有c 就可以<br> <code>/^[abc]$/</code>  三选一，只要是有a 或者b 或者c 这三个字母才返回</p>
</li>
<li><p><code>[ - ]</code><br> <code>/^[a-z]$/</code>  26个英文字母任何一个字母就可以，必须是英文</p>
</li>
<li><p>字符组合<br> <code>/^[a-zA-Z0-9_-]$/</code></p>
</li>
<li><p>^取反<br> <code>/^[ ^ 123]$/</code>  <code>[ ]</code>内部的<code>^</code>表示取反，不能有里面的内容</p>
<h4 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h4></li>
<li><p>*相当于&gt;=0  可以出现0次或很多次</p>
</li>
<li><p>+相当于&gt;=1  可以出现1次或很多次</p>
</li>
<li><p>?相当于1||0      0次或者1次</p>
</li>
<li><p>{3}就是重复3次  / ^a{3}$/</p>
</li>
<li><p>{3,} 就是大于等于3</p>
</li>
<li><p>{3,16} 大于等于3，小于等于16</p>
</li>
<li><p><code>/^[a-zA-Z0-9_-]{6,16}$/</code>表示6-16位之间，必须从里面去选择</p>
</li>
<li><p><code>/^abc$/</code> 必须是abc</p>
</li>
<li><p><code>/^[abc]$/</code>  a或b或c</p>
</li>
<li><p><code>/^a{3}$/</code>  必须是aaa</p>
</li>
<li><p><code>/^abc{3}$/</code>  必须是abccc</p>
</li>
<li><p><code>/^(abc){3}$/</code>  abcabcabc </p>
</li>
<li><p>{ } 表示多少次</p>
</li>
<li><p>[ ]表示多选一</p>
</li>
<li><p>( )表示优先级</p>
<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3></li>
<li><p>某些模式的简写方式</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code></li>
<li><code>\D</code> 匹配0-9以外的字符，相当于<code>[ ^ 0-9]</code></li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[a-zA-Z0-9_]</code></li>
<li><code>\W</code> 除所有字母数字和下划线以外的字符，相当于<code>[ ^a-zA-Z0-9]</code></li>
<li><code>\s</code>  匹配空格（包括换行符、制表符、空格符等），相当于<code>[\t\r\n\v\f]</code></li>
<li><code>\S</code>匹配非空格的字符，相当于[ ^\t\r\n\v\f]</li>
</ul>
</li>
<li><p><code>/\w{6,16}/</code></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3></li>
<li><p>座机号码 两种格式：<code>010-12345678</code>  <code>0120-1234567</code><br><code>/\d{3}-\d{8}|\d{4}-\d{7}/</code></p>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>replace(原内容，新内容)</code></p>
</li>
<li><p><code>replace(/激情/，&quot;**&quot;)</code></p>
</li>
<li><p>/表达式/[switch]</p>
<ul>
<li>g  全局匹配 replace(/激情/g,’**’)   replace(/激情|gay/g,’ * *’)</li>
<li>i  忽略大小写</li>
<li>gi 全局匹配和忽略大小写</li>
</ul>
</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const fn = <span class="function"><span class="params">(name)</span>=&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;<span class="attr">name</span>:<span class="string">"张三"</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">​		<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">​	  <span class="keyword">return</span> <span class="function"><span class="params">( )</span> =&gt;</span> &#123;</span><br><span class="line">​		    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">​	  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  resFn = fn.call(obj);</span><br><span class="line">resFn();</span><br></pre></td></tr></table></figure>
<p>// 第一个this是obj对象，第二个this也是obj对象。<br><strong>箭头函数不绑定this关键字，箭头函数的this，指向的是函数定义位置的上下文this</strong>。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">​     age:<span class="number">20</span>;</span><br><span class="line">​			say:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">​				<span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">​			&#125;</span><br><span class="line">​	&#125;</span><br><span class="line">obj.say()  <span class="regexp">//</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>因为箭头函数定义在obj对象里，但是obj对象不能产生作用域，因此，箭头函数被定义在全局作用域下。this指向Window，所以是window对象下的age。如果此时有 var age = 100；则输出装值为100.</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>在箭头函数中，没有arguments哦~~</p>
<ul>
<li>收集剩余的参数，<strong>只能放在末尾</strong>！！！</li>
<li>展开数组，展开后的效果，就跟把数组的内容之间写在这儿一样。<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">sum</span> = (...<span class="keyword">args</span>) =&gt; &#123;</span><br><span class="line">  let <span class="keyword">total</span> = 0;</span><br><span class="line">  <span class="keyword">args</span>.<span class="keyword">forEach</span>(item =&gt; <span class="keyword">total</span> + item )</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">total</span> ;</span><br><span class="line">​&#125;</span><br><span class="line"><span class="built_in">sum</span>(10,20);</span><br><span class="line"><span class="built_in">sum</span>(10,20,30)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h2><p>详情见<a href="https://www.runoob.com/w3cnote/es6-reflect-proxy.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>一个 Proxy 对象由两个部分组成： <strong>target</strong> 、 <strong>handler</strong> 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, key) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getting '</span>+key);</span><br><span class="line">        <span class="keyword">return</span> target[key]; <span class="comment">// 不是target.key</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(target, key, value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setting '</span>+key);</span><br><span class="line">        target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">proxy.name     <span class="comment">// 实际执行 handler.get</span></span><br><span class="line">proxy.age = <span class="number">25</span> <span class="comment">// 实际执行 handler.set</span></span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// setting age</span></span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// target 可以为空对象</span></span><br><span class="line"><span class="keyword">let</span> targetEpt = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEpt = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEpt, handler)</span><br><span class="line"><span class="comment">// 调用 get 方法，此时目标对象为空，没有 name 属性</span></span><br><span class="line">proxyEpt.name <span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// 调用 set 方法，向目标对象中添加了 name 属性</span></span><br><span class="line">proxyEpt.name = <span class="string">'Tom'</span></span><br><span class="line"><span class="comment">// setting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"><span class="comment">// 再次调用 get ，此时已经存在 name 属性</span></span><br><span class="line">proxyEpt.name</span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相</span></span><br><span class="line"><span class="comment">// 影响</span></span><br><span class="line">targetEpt)</span><br><span class="line"><span class="comment">// &#123;name: "Tom"&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象</span></span><br><span class="line"><span class="keyword">let</span> targetEmpty = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEmpty = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEmpty,&#123;&#125;)</span><br><span class="line">proxyEmpty.name = <span class="string">"Tom"</span></span><br><span class="line">targetEmpty) <span class="comment">// &#123;name: "Tom"&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实例方法</li>
</ul>
<p><strong>get(target, propKey, receiver)</strong><br>用于 target 对象上 propKey 的读取操作。get() 方法可以继承。<br><strong>set(target, propKey, value, receiver)</strong><br>用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。<br><strong>apply(target, ctx, args)</strong><br>用于拦截函数的调用、call 和 reply 操作。target 表示目标对象，ctx 表示目标对象上下文，args 表示目标对象的参数数组。<br><strong>has(target, propKey)</strong><br>用于拦截 HasProperty 操作，即在判断 target 对象是否存在 propKey 属性时，会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。</p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p><strong>Reflect.get(target, name, receiver)</strong><br>查找并返回 target 对象的 name 属性。<br><strong>Reflect.set(target, name, value, receiver)</strong><br>将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错。<br><strong>Reflect.has(obj, name)</strong><br>是 name in obj 指令的函数化，用于查找 name 属性在 obj 对象中是否存在。返回值为 boolean。如果 obj 不是对象则会报错 TypeError。<br><strong>Reflect.deleteProperty(obj, property)</strong><br>是 delete obj[property] 的函数化，用于删除 obj 对象的 property 属性，返回值为 boolean。如果 obj 不是对象则会报错 TypeError。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题优化配置</title>
    <url>/2020/04/06/Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天使用Hexo搭了一个博客，在不断优化过程中去不断的搜集教程，在这里我把自己使用到的方面记录下来，方便今后的查阅。</p>
<a id="more"></a>
<h2 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h2><p>在写博客的过程中，对markdown语法还不是特别熟悉，记录几个语法吧。</p>
<h3 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">半方大的空白   <span class="symbol">&amp;ensp;</span>  或  <span class="symbol">&amp;#8194;</span></span><br><span class="line">全方大的空白   <span class="symbol">&amp;emsp;</span>  或  <span class="symbol">&amp;#8195;</span></span><br><span class="line">不断行的空白格 <span class="symbol">&amp;nbsp;</span>  或  <span class="symbol">&amp;#160;</span></span><br></pre></td></tr></table></figure>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内式链接形式：[<span class="string">超链接文字</span>](<span class="link">url</span>) </span><br><span class="line">[百度]https://www.baidu.com)</span><br></pre></td></tr></table></figure>
<p><strong>在新窗口打开页面</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"/work/manager/index.html"</span> <span class="attribute">target</span>=<span class="string">"_blank"</span>&gt;共享单车后台管理系统&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p><a href="/work/manager/index.html" target="_blank">共享单车后台管理系统</a></p>
<h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(<span class="number">1</span>.jpg)  <span class="comment">//图片放在与文章同名的文件夹中</span></span><br></pre></td></tr></table></figure>
<h3 id="文字颜色"><a href="#文字颜色" class="headerlink" title="文字颜色"></a>文字颜色</h3><p>这是<label style="color:red">红色</label>字体</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">这是&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">"color:red"</span>&gt;红色&lt;/<span class="built_in">label</span>&gt;字体</span><br></pre></td></tr></table></figure>
<h2 id="Next主题优化"><a href="#Next主题优化" class="headerlink" title="Next主题优化"></a>Next主题优化</h2><h3 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h3><p>&emsp;&emsp;在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 <strong>阅读全文</strong> 按钮，可以通过以下方法：<br>1.在文章中使用<code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo 提供的方式<br>2.在文章的 <code>front-matter</code> 中添加 <code>description</code>，并提供文章摘录<br>3.自动形成摘要，在 <strong>主题配置文件</strong> 中添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>
<p>默认截取的长度为 150 字符，可以根据需要自行设定</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo从零开始搭建博客</title>
    <url>/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>&emsp;&emsp;之前做了一个个人主页，但是由于部署在github，导致国内网打开很慢的原因，因此上网搜索了一些解决的办法。看到很多搭建博客的方法，索性不如也把自己的博客搭建起来，于是乎，特此写一篇笔记记录一下心得以及踩过的大部分坑吧~</p>
<a id="more"></a> 

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>打开<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>下载安装node.js<br><img src="/.com//1.png" alt></p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>打开<a href="https://git-scm.com/download" target="_blank" rel="noopener">Git官网</a>,选择下载对应版本安装<br><img src="/.com//2.png" alt></p>
<h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>由于npm的服务器位于国外可能影响安装，为了提高下载速度，我们来安装一个cnpm<br><code>npm install cnpm -g --registry=https://registry.npm.taobao.org</code></p>
<h3 id="全局安装hexo"><a href="#全局安装hexo" class="headerlink" title="全局安装hexo"></a>全局安装hexo</h3><p><code>cnpm install -g hexo</code></p>
<h2 id="搭建一个博客"><a href="#搭建一个博客" class="headerlink" title="搭建一个博客"></a>搭建一个博客</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>输入<code>hexo init</code>初始化项目<br>然后会出现这样一个目录<br><img src="/.com//3.png" alt></p>
<h3 id="打包成静态文件"><a href="#打包成静态文件" class="headerlink" title="打包成静态文件"></a>打包成静态文件</h3><p>输入<code>hexo g</code>会将文件编译为静态文件，md格式会编译为html<br>此时文件中会多出一个<code>public</code>文件夹</p>
<h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p>输入<code>hexo s</code> 运行，在浏览器中输入 <code>http://localhost:4000</code><br><img src="/.com//4.png" alt></p>
<h2 id="部署到码云"><a href="#部署到码云" class="headerlink" title="部署到码云"></a>部署到码云</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>进入<a href="https://gitee.com/" target="_blank" rel="noopener">码云官网</a>，登录账号，创建一个仓库，注意仓库路径必须是<code>&lt;user-name&gt;.github.io</code>,<code>&lt;user-name&gt;</code>是自己的用户名<br><img src="/.com//5.png" alt><br><img src="/.com//6.png" alt></p>
<h3 id="连接仓库"><a href="#连接仓库" class="headerlink" title="连接仓库"></a>连接仓库</h3><p>点击仓库旁的 克隆下载，复制https地址<br><img src="/.com//7.png" alt><br>然后打开blog文件夹中的<code>_config.yml</code>文件（项目配置文件），搜索<code>deploy</code><br>将repo:后面的网址改成你复制的地址，保存。<br><img src="/.com//8.png" alt></p>
<h3 id="推送到仓库"><a href="#推送到仓库" class="headerlink" title="推送到仓库"></a>推送到仓库</h3><p>安装<code>hexo-deployer-git</code>模块，gitbash 运行 <code>cnpm install hexo-deployer-git --save</code></p>
<p>安装好之后，文件夹会多出来一个.deploy_git,然后运行命令 <code>hexo g -d</code>,就可以把内容推送到码云了。</p>
<h3 id="开启码云Page服务"><a href="#开启码云Page服务" class="headerlink" title="开启码云Page服务"></a>开启码云Page服务</h3><p>点击仓库右上角的服务，然后点击Gitee Pages<br><img src="/.com//9.png" alt><br><img src="/.com//10.png" alt><br>注意，以后每次提交至gitee后都要来手动更新哦~~也可以花钱购买自动部署服务</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>js 编程题系列（一）</title>
    <url>/2020/04/15/JS%E7%BC%96%E7%A8%8B%E9%A2%98%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>方法一:使用ES6中的reduce</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span>   arr.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>方法二：遍历数组求和，可以用到for循环，forEach等等</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line"><span class="comment">//forEach</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(arr)</span> &#123;</span></span><br><span class="line">    var <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    arr.forEach(item =&gt;&#123;</span><br><span class="line">        <span class="built_in">sum</span> += item</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for of</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(arr)</span> &#123;</span></span><br><span class="line">    var <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (let item of arr)&#123;</span><br><span class="line">        <span class="built_in">sum</span> += item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h3 id="移除数组-arr-中的所有值与-item-相等的元素。不要直接修改数组-arr，结果返回新的数组"><a href="#移除数组-arr-中的所有值与-item-相等的元素。不要直接修改数组-arr，结果返回新的数组" class="headerlink" title="移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组"></a>移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组</h3><p>方法一：创建空数组，遍历arr，满足value等于item的，就push</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span><span class="built_in"> remove</span>(arr, <span class="type">item</span>) &#123;</span><br><span class="line">    var result=[];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">value</span> <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">value</span> !== <span class="type">item</span>)&#123;</span><br><span class="line">            result.push(<span class="keyword">value</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：使用filter方法</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span><span class="built_in"> remove</span>(arr, <span class="type">item</span>) &#123;</span><br><span class="line">    var arr_filter = arr<span class="built_in">.filter</span>(<span class="keyword">function</span>(<span class="keyword">value</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span> != <span class="type">item</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr_filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三：正则表达式</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="title">arr</span>, <span class="title">item</span>) &#123;</span></span><br><span class="line">    <span class="literal">return</span> arr.join(<span class="string">''</span>).<span class="built_in">replace</span>(<span class="built_in">new</span> RegExp(<span class="keyword">item</span>,<span class="string">'g'</span>),<span class="string">''</span>).<span class="built_in">split</span>(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除数组-arr-中的所有值与-item-相等的元素，直接在给定的-arr-数组上进行操作，并将结果返回"><a href="#移除数组-arr-中的所有值与-item-相等的元素，直接在给定的-arr-数组上进行操作，并将结果返回" class="headerlink" title="移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回"></a>移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回</h3><p>因为要在原数组上修改，使用splice方法，每删掉一个元素，在它后面的元素索引号会少1,使用for循环要注意</p>
<p>方法一：倒着遍历</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span><span class="params">(arr, item)</span> &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (var <span class="built_in">i</span> = arr.<span class="built_in">length</span>; <span class="built_in">i</span> &gt;= <span class="number">0</span>; <span class="built_in">i</span>--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="built_in">i</span>] == item) &#123;</span><br><span class="line">            arr.splice(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：while循环</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span><span class="params">(arr, item)</span> &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (var <span class="built_in">i</span> in arr) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[<span class="built_in">i</span>] == item)&#123;</span><br><span class="line">            arr.splice(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>编程题</category>
      </categories>
  </entry>
  <entry>
    <title>共享单车管理系统之框架之主页面架构设计</title>
    <url>/2020/04/05/%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>前一段时间跟着视频的学习一步一步完成了 共享单车管理系统 的开发，本次想要重新再回顾一遍，自己动手开始吧~</p>
<a id="more"></a> 

<h2 id="两种方式创建一个react应用"><a href="#两种方式创建一个react应用" class="headerlink" title="两种方式创建一个react应用"></a>两种方式创建一个react应用</h2><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">npm </span><span class="string">install </span><span class="built_in">create-react-app</span> -g</span><br><span class="line"><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">npx </span><span class="string">install </span><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br></pre></td></tr></table></figure>
<p>直接使用官方的脚手架吧~<br><code>npm start</code>运行</p>
<h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><h3 id="全局安装yarn"><a href="#全局安装yarn" class="headerlink" title="全局安装yarn"></a>全局安装yarn</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> yarn -g</span><br></pre></td></tr></table></figure>
<h3 id="安装react-router"><a href="#安装react-router" class="headerlink" title="安装react-router"></a>安装<code>react-router</code></h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> react-router-dom --save</span></span><br></pre></td></tr></table></figure>
<h3 id="安装AntD"><a href="#安装AntD" class="headerlink" title="安装AntD"></a>安装AntD</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">yarn add <span class="symbol">antd@</span><span class="number">3.4</span><span class="number">.3</span> --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="安装less-less-loader-因为ant-d是基于less开发的"><a href="#安装less-less-loader-因为ant-d是基于less开发的" class="headerlink" title="安装less less-loader 因为ant-d是基于less开发的"></a>安装less less-loader 因为ant-d是基于less开发的</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yarn add <span class="keyword">less</span> <span class="keyword">less</span>-loader --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="初始化git并且提交"><a href="#初始化git并且提交" class="headerlink" title="初始化git并且提交"></a>初始化git并且提交</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git <span class="keyword">add</span><span class="bash"> ./</span></span><br><span class="line">git commit -m <span class="string">'1 commit'</span></span><br></pre></td></tr></table></figure>
<h3 id="暴露webpack配置文件"><a href="#暴露webpack配置文件" class="headerlink" title="暴露webpack配置文件"></a>暴露webpack配置文件</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">yarn eject  <span class="regexp">//</span>执行之前必须先提交,否则会报以下错误</span><br><span class="line"></span><br><span class="line">Remove untracked files, stash or commit any changes, and try again.</span><br><span class="line">error Command failed with <span class="keyword">exit</span> code <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件，使用less-loader去解析less文件"><a href="#修改配置文件，使用less-loader去解析less文件" class="headerlink" title="修改配置文件，使用less-loader去解析less文件"></a>修改配置文件，使用<code>less-loader</code>去解析<code>less</code>文件</h3><p>  找到<code>config</code>文件下的<code>webpack.config.js</code>文件,找到并修改第48和110行<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// style files regexes</span></span><br><span class="line"><span class="keyword">const</span> cssRegex = <span class="regexp">/\.(css|less)$/</span>; <span class="comment">//修改第48行</span></span><br><span class="line"><span class="keyword">const</span> cssModuleRegex = <span class="regexp">/\.module\.css$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassRegex = <span class="regexp">/\.(scss|sass)$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassModuleRegex = <span class="regexp">/\.module\.(scss|sass)$/</span>;</span><br></pre></td></tr></table></figure><br>  <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds PostCSS Normalize as the reset css with default options,</span></span><br><span class="line">           <span class="comment">// so that it honors browserslist config in package.json</span></span><br><span class="line">           <span class="comment">// which in turn let's users customize the target behavior as per their needs.</span></span><br><span class="line">           <span class="selector-tag">postcssNormalize</span>(),</span><br><span class="line">         ],</span><br><span class="line">         <span class="selector-tag">sourceMap</span>: <span class="selector-tag">isEnvProduction</span> <span class="selector-tag">&amp;</span><span class="selector-tag">&amp;</span> <span class="selector-tag">shouldUseSourceMap</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attribute">loader</span>:require.resolve(<span class="string">'less-loader'</span>)    <span class="comment">//修改行</span></span><br><span class="line">     &#125;</span><br><span class="line">   ]<span class="selector-class">.filter</span>(Boolean);</span><br></pre></td></tr></table></figure><br>由于use数组的执行顺序是从后到前，故在最下方添加<code>less-loader</code>加载则会被最先执行。修改完文件内容后需要重启项目<code>yarn start</code>生效。</p>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>因为每次使用ant-d组件的时候，都要引入ant-d.css样式文件，但实际上我们并不需要所有组件的样式。<br>为了提高性能，我们希望只引入我们使用到的组件的样式，实现<strong>按需加载</strong></p>
<h3 id="安装-react-app-rewired-插件"><a href="#安装-react-app-rewired-插件" class="headerlink" title="安装 react-app-rewired 插件"></a>安装 react-app-rewired 插件</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> react-app-rewired customize-cra</span></span><br></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* package.json */</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">-   <span class="string">"start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line">+   <span class="string">"start"</span>: <span class="string">"react-app-rewired start"</span>,</span><br><span class="line">-   <span class="string">"build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line">+   <span class="string">"build"</span>: <span class="string">"react-app-rewired build"</span>,</span><br><span class="line">-   <span class="string">"test"</span>: <span class="string">"react-scripts test"</span>,</span><br><span class="line">+   <span class="string">"test"</span>: <span class="string">"react-app-rewired test"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在项目根目录创建一个 <code>config-overrides.js</code> 用于修改默认配置。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>.exports = function <span class="keyword">override</span>(<span class="built_in">config</span>, env) &#123;</span><br><span class="line">  <span class="comment">// do stuff with the webpack config...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">config</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>yarn start</code>命令运行之后报错：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Error: </span>Cannot find module 'react-scripts/package.json'</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong>：缺少react-scripts插件<br><strong>解决方案</strong>：安装 react-scripts 插件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save react-scripts</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo过程中遇到的坑</title>
    <url>/2020/04/04/hexo%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天突然心血来潮，想要自己搭建一个博客，正好可以将以前的笔记给系统整理一下。我的博客是使用<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>进行搭建的，跟着网上的教程一步一步的来，却不曾想老是碰见一些问题，不得不去查了好多资料来。在这里就记录几个自己在使用hexo过程中遇到的问题以及记录一下解决的方法。</p>
<a id="more"></a> 

<h2 id="各种问题"><a href="#各种问题" class="headerlink" title="各种问题"></a>各种问题</h2><h3 id="本地测试的时候刷新无效"><a href="#本地测试的时候刷新无效" class="headerlink" title="本地测试的时候刷新无效"></a>本地测试的时候刷新无效</h3><p>优化主题时，修改文件根目录下的<code>_config.yml</code>站点配置目录后，要重新启动Hexo再刷新，修改next主题目录下的<code>_config.yml</code>主题配置目录则只需刷新即可.</p>
<h3 id="使用npm安装插件报错"><a href="#使用npm安装插件报错" class="headerlink" title="使用npm安装插件报错"></a>使用npm安装插件报错</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> ERR! Cannot read property <span class="string">'match'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">npm</span> ERR! A complete log <span class="keyword">of</span> <span class="keyword">this</span> run can be found in:</span><br><span class="line"><span class="built_in">npm</span> ERR!     C:\Users\Administrator\AppData\Roaming\<span class="built_in">npm</span>-cache\_logs\<span class="number">2020</span><span class="number">-04</span><span class="number">-04</span>T12_05_08_782Z-debug.log</span><br></pre></td></tr></table></figure>

<p><code>npm cache clear --force</code>   清除npm本地缓存<br>如果不行，就删除 <code>package-lock.json</code> （这两个办法能够解决我目前遇到的这种情况）<br>再不行的话，就依次执行以下代码：<br>    <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rm</span> <span class="string">-rf node_modules</span></span><br><span class="line"><span class="attr">rm</span> <span class="string">package-lock.json</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">cache clear --force</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure></p>
<h3 id="hexo-helper-live2d相关报错"><a href="#hexo-helper-live2d相关报错" class="headerlink" title="hexo-helper-live2d相关报错"></a>hexo-helper-live2d相关报错</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>Plugin load failed: hexo-helper-live2d</span><br><span class="line"><span class="keyword">Error: </span>Cannot find module 'live2d-widget/lib/manifest'</span><br><span class="line">Require stack:</span><br></pre></td></tr></table></figure>
<p>想要放一个2d模型来着，于是乎跟着教程一边做着，就是运行不起来，最后连正常的页面都显示不了<br>最后通过上一个问题的方法，再加上 <code>hexo clean</code> 解决</p>
<h3 id="hexo-s-报错"><a href="#hexo-s-报错" class="headerlink" title="hexo s 报错"></a>hexo s 报错</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">FATAL bad indentation <span class="keyword">of</span> a <span class="keyword">mapping</span> entry at <span class="type">line</span> <span class="number">103</span>, <span class="keyword">column</span> <span class="number">7</span>:</span><br><span class="line">      <span class="keyword">type</span>: git</span><br><span class="line">          ^</span><br></pre></td></tr></table></figure>
<p>这种问题就是常见的语法错误啦，属性的后面应该跟 <code>英文字符的冒号</code>，再跟值</p>
<h3 id="文章中设置超链接跳转到本地html文件"><a href="#文章中设置超链接跳转到本地html文件" class="headerlink" title="文章中设置超链接跳转到本地html文件"></a>文章中设置超链接跳转到本地html文件</h3><p>因为每次运行<code>hexo g</code>的时候，会自动将文件进行编译，会给文本添加格式与标签<br>如果想要设置自定义页面,首先将自定义的页面放入<code>/resource</code>文件下,这个文件下的所有文件最终会直接放到<code>public</code>静态文件夹中，想要引入里面的文件，直接引用路径即可。<br>为了避免html被编译，需要设置 跳过渲染 ,在配置文件<code>.config.yml</code>中进行配置。下面举个例子：</p>
<p><code>/resource</code> 文件目录下创建了一个 <code>work</code> 文件夹,此时需要引入 <code>work</code> 下面的 <code>index.html</code> 文件，需要在配置文件<code>.config.yml</code>中设置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">skip_render:</span></span><br><span class="line">    - <span class="string">'work/**'</span></span><br><span class="line"></span><br><span class="line">引入的时候只需要使用 `![](<span class="regexp">/work/</span>index.html)`</span><br></pre></td></tr></table></figure>
<h3 id="重新部署的问题"><a href="#重新部署的问题" class="headerlink" title="重新部署的问题"></a>重新部署的问题</h3><p>每次重新推送到gitee之后刷新页面都没有更新，但是在本地运行明明是OK的。最开始怎么也发现不了问题在哪里，最后脑壳都蒙圈了，发现竟然是gitee的pages服务需要手动刷新。。。。<br>这算是最我进的最大的坑了吧。。。<br><img src="/.com//1.png" alt></p>
<h3 id="插入图片无法显示的问题"><a href="#插入图片无法显示的问题" class="headerlink" title="插入图片无法显示的问题"></a>插入图片无法显示的问题</h3><p>如何在文章中插入图片？</p>
<ul>
<li><p>先要将配置<code>_config.yml</code>里面的<code>post_asset_folder:false</code>这个选项设置为<code>true</code>。</p>
</li>
<li><p><code>npm install hexo-asset-image</code>,这样运行<code>hexo n &quot;xxx&quot;</code>来生成博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹，把图片放入该文件夹。（也可以手动创建同名文件夹）</p>
</li>
<li><p>再使用<code>![xxx](xxx/xxx.png)</code>引入图片</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">link</span> <span class="keyword">as</span>:<span class="comment">--&gt;/.com//1.png</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">link</span> <span class="keyword">as</span>:<span class="comment">--&gt;/.com//2.png</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">link</span> <span class="keyword">as</span>:<span class="comment">--&gt;/.com//3.png</span></span><br></pre></td></tr></table></figure>
<p>如果<code>hexo s</code>运行时出现上面代码，但是图片依旧不显示,是由于hexo3版本后对很多插件支持有问题<br>可直接安装已经修改过得插件<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code></p>
<p>注意每次都要使用 <code>hexo clean</code> 删除静态文件再重新运行奥~</p>
<h3 id="添加按钮之后，点击阅读全文会自动跳转到more后面的内容"><a href="#添加按钮之后，点击阅读全文会自动跳转到more后面的内容" class="headerlink" title="添加按钮之后，点击阅读全文会自动跳转到more后面的内容"></a>添加<!-- more-->按钮之后，点击阅读全文会自动跳转到more后面的内容</h3><p>在themes/next/layout/_macro/post.swig中找到以下部分，文章会自动跳转到#more<br>不想跳转直接去掉即可</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;%- <span class="name"><span class="name">if</span></span> theme.read_more_btn %&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-button"</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(post.path) &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">#more"</span> <span class="attr">rel</span>=<span class="string">"contents"</span>&gt;</span> //可以去掉#more</span></span><br><span class="line"><span class="xml">                </span><span class="template-variable">&#123;&#123; __('post.read_more') &#125;&#125;</span><span class="xml"> <span class="symbol">&amp;raquo;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          </span><span class="template-tag">&#123;%- <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>


<p>参考<br><a href="https://blog.csdn.net/sinat_42338962/article/details/94388760" target="_blank" rel="noopener">https://blog.csdn.net/sinat_42338962/article/details/94388760</a><br><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">https://www.jianshu.com/p/3db6a61d3782</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>js实现斐波那契数列</title>
    <url>/2020/04/12/js%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>使用JavaScript实现斐波那契数列[1,1,2,3,5,8…]</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列</span></span><br><span class="line">        <span class="comment">//方法一：</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fib1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                c = a + b;</span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(fib1(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法二:</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fib2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (arr.length &lt;= n) &#123;</span><br><span class="line">                num = arr[arr.length - <span class="number">1</span>] + arr[arr.length - <span class="number">2</span>];</span><br><span class="line">                arr.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr[n]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(fib2(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法三：</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fib3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fib3(n - <span class="number">1</span>) + fib3(n - <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(fib3(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>编程题</category>
      </categories>
  </entry>
  <entry>
    <title>promise</title>
    <url>/2020/04/10/%E6%80%BB%E7%BB%93%E5%87%A0%E4%B8%AA%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<p>总结ES6中的promise的用法，以及相关的概念。</p>
<a id="more"></a>

<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>promise</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>安恒信息笔试总结</title>
    <url>/2020/04/12/%E5%AE%89%E6%81%92%E4%BF%A1%E6%81%AF%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今日份的笔试</p>
<a id="more"></a>
<h2 id="选择部分"><a href="#选择部分" class="headerlink" title="选择部分"></a>选择部分</h2><h3 id="哪些事件是冒泡"><a href="#哪些事件是冒泡" class="headerlink" title="哪些事件是冒泡"></a>哪些事件是冒泡</h3><p>不是所有事件都冒泡，记住不冒泡的就好啦。<br>blur、focus、load、unload、abort、error、mouseenter、mouseleave、resize、DOMNodeInsertedIntoDocument、DOMNodeRemovedFromDocument是不冒泡的；media相关事件，都不冒泡</p>
<h3 id="哪些是兄弟选择器"><a href="#哪些是兄弟选择器" class="headerlink" title="哪些是兄弟选择器"></a>哪些是兄弟选择器</h3><p>相邻兄弟选择器  div+p<br>后续兄弟选择器  div~p</p>
<h3 id="堆排序的初始堆"><a href="#堆排序的初始堆" class="headerlink" title="堆排序的初始堆"></a>堆排序的初始堆</h3><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
<h3 id="svg-jpeg-gif-png"><a href="#svg-jpeg-gif-png" class="headerlink" title="svg/jpeg/gif/png"></a>svg/jpeg/gif/png</h3><p><strong>JPEG</strong><br>采用特殊的<span style="color:#EC7259">有损压缩</span>算法，将不易被人眼察觉的图像颜色删除，从而达到较大的压缩比(可达到2:1甚至40:1)，因为JPEG格式的文件尺寸较小，下载速度快,所以是互联网上最广泛使用的格式。<br><strong>GIF</strong><br>不仅可以是一张静止的图片,也可以是<span style="color:#EC7259">动画</span>，并且支持<span style="color:#EC7259">透明背景图像</span>，适用于多种操作系统，“体型”很小，网上很多小动画都是GIF格式。但是其<span style="color:#EC7259">色域不广</span>,只支持256种颜色。<br><strong>PNG</strong><br>与JPG格式类似,网页中有很多图片都是这种格式，压缩比高于GIF，支持<span style="color:#EC7259">图像透明</span>，可以利用Alpha通道调节图像的透明度,是网页三剑客之一Fireworks的源文件。<br><strong>BMP</strong><br>Windows系统下的标准位图格式,未经过压缩，一般图像文件会比较大。在很多软件中被广泛应用。<br><strong>SVG</strong><br>它的英文全称为Scalable Vector Graphics，意思为可缩放的矢量图形。用户可以直接<span style="color:#EC7259">用代码来描绘图像</span>，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来观看。</p>
<p>链接：<a href="https://www.jianshu.com/p/6e1941de7952" target="_blank" rel="noopener">https://www.jianshu.com/p/6e1941de7952</a></p>
<h2 id="简答部分"><a href="#简答部分" class="headerlink" title="简答部分"></a>简答部分</h2><h3 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h3><p>SQL Injection：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。<br><a href="https://blog.csdn.net/qq_34638225/article/details/81269281" target="_blank" rel="noopener">https://blog.csdn.net/qq_34638225/article/details/81269281</a></p>
<h3 id="JavaScript-Prototype污染攻击漏洞的原理"><a href="#JavaScript-Prototype污染攻击漏洞的原理" class="headerlink" title="JavaScript Prototype污染攻击漏洞的原理"></a>JavaScript Prototype污染攻击漏洞的原理</h3><p>关键词：prototype   <strong>proto</strong>  原型链 继承，原型上的属性被修改，则继承构造函数的实例的属性也会被修改。<br><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x01-prototype__proto" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x01-prototype__proto</a>__</p>
<h3 id="简述HTTP与HTTPS及区别"><a href="#简述HTTP与HTTPS及区别" class="headerlink" title="简述HTTP与HTTPS及区别"></a>简述HTTP与HTTPS及区别</h3><p><strong>HTTP</strong>：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br><strong>HTTPS</strong>：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p><strong>HTTPS和HTTP的区别主要如下：</strong><br>1.HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。<br>2.使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。<br>3.HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。<br>4.http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>5.HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，HTTPS 要比 HTTP 要更耗费服务器资源。<br><a href="https://www.runoob.com/w3cnote/http-vs-https.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/http-vs-https.html</a><br>TCP三次握手</p>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>拼多多笔试总结</title>
    <url>/2020/04/10/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今日份的笔试总结，凭记忆啦~</p>
<a id="more"></a>

<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><h3 id="http的特点"><a href="#http的特点" class="headerlink" title="http的特点"></a>http的特点</h3><p>HTTP协议的主要特点可概括如下：</p>
<p>1.<strong>支持客户/服务器模式</strong>。</p>
<p>2.<strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>3.<strong>灵活</strong>：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</p>
<p>4.<strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>5.<strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</p>
<h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max()"></a>Math.max()</h3><p>Math.max(value1[,value2, …]);<br>Math.max.apply(null, numberArray);<br>Math.max.call(null, value1[,value2,…]);<br>返回给定的一组数字中的最大值。如果给定的参数中至少有一个参数无法被转换成数字，则会返回 NaN。<br>由于 max 是 Math 的静态方法，所以应该像这样使用：Math.max()，而不是创建的 Math 实例的方法（Math 不是构造函数）。<br>如果没有参数，则结果为 - Infinity。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">console.log(Math.max(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)); <span class="comment">//3</span></span><br><span class="line">console.log(Math.max([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">//NaN</span></span><br><span class="line">console.log(Math.max.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">//3</span></span><br><span class="line">console.log(Math.max.call(<span class="literal">null</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h3 id="flex-flow是哪两个属性"><a href="#flex-flow是哪两个属性" class="headerlink" title="flex-flow是哪两个属性"></a>flex-flow是哪两个属性</h3><p>详见另外一篇css讲解：<a href="https://evelyn-lin.gitee.io/2020/04/08/CSS%E4%B9%8B%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">CSS之我的知识盲区(一)</a></p>
<h3 id="ip地址的分类和子网掩码"><a href="#ip地址的分类和子网掩码" class="headerlink" title="ip地址的分类和子网掩码"></a>ip地址的分类和子网掩码</h3><table>
<thead>
<tr>
<th>类别</th>
<th>IP地址范围</th>
<th>私网IP地址范围</th>
<th>子网掩码</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>1.0.0.1-127.255.255.254</td>
<td>10.0.0.0-10.255.255.255</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B</td>
<td>128.0.0.1-191.255.255.254</td>
<td>172.16.0.0-172.31.255.255</td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C</td>
<td>192.0.0.1-223.255.255.254</td>
<td>192.168.0.0-192.168.255.255</td>
<td>255.255.255.0</td>
</tr>
</tbody></table>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="浏览器本地存储的三种方式"><a href="#浏览器本地存储的三种方式" class="headerlink" title="浏览器本地存储的三种方式"></a>浏览器本地存储的三种方式</h3><p>cookie localStorage  sessionStorage<br><a href="https://segmentfault.com/a/1190000012607546" target="_blank" rel="noopener">总结本地存储的几种方式</a><br><a href="https://mp.weixin.qq.com/s/oOGIuJCplPVW3BuIx9tNQg" target="_blank" rel="noopener">这一次带你彻底了解cookie</a></p>
<h3 id="字符串和数值的加法运算"><a href="#字符串和数值的加法运算" class="headerlink" title="字符串和数值的加法运算"></a>字符串和数值的加法运算</h3><p>在加法/减法运算中，true和false会转换为1和0，null也是0，undefined参与的运算为NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="number">5</span>); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="string">'5'</span>); <span class="comment">// '55'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="literal">true</span>); <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="literal">false</span>); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="literal">undefined</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="literal">null</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<h3 id="重排与重绘"><a href="#重排与重绘" class="headerlink" title="重排与重绘"></a>重排与重绘</h3><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="js执行机制"><a href="#js执行机制" class="headerlink" title="js执行机制"></a>js执行机制</h3><p>同步任务与异步任务<br>微任务与宏任务  promise async await<br><a href="https://blog.csdn.net/ZD717822023/article/details/97491152" target="_blank" rel="noopener">JS执行机制详解</a></p>
<h3 id="函数this指向问题，包括匿名函数、ES6对象方法简写中的this、自执行函数"><a href="#函数this指向问题，包括匿名函数、ES6对象方法简写中的this、自执行函数" class="headerlink" title="函数this指向问题，包括匿名函数、ES6对象方法简写中的this、自执行函数"></a>函数this指向问题，包括匿名函数、ES6对象方法简写中的this、自执行函数</h3><p>方法中的this，指向方法的调用者；<br>普通函数的this，指向他的调用者；<br>箭头函数的this，永远指向上下文，注意call、apply的情况；<br>构造函数的this，指向他的实例；<br><a href="https://blog.csdn.net/dreamjay1997/article/details/81978921" target="_blank" rel="noopener">函数里的this指向问题</a></p>
<h3 id="写出能返回数组中相同元素的方法"><a href="#写出能返回数组中相同元素的方法" class="headerlink" title="写出能返回数组中相同元素的方法"></a>写出能返回数组中相同元素的方法</h3><p>先写一个自己答的方法吧~<br>方法一：利用sort方法，先使用sort方法将数组排序，再来判断找出重复元素</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">same</span><span class="params">(arr)</span> &#123;</span></span><br><span class="line">    arr.<span class="built_in">sort</span>();</span><br><span class="line">    let newArr = [];</span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="built_in">i</span>] == arr[<span class="built_in">i</span>+<span class="number">1</span>]) &#123;</span><br><span class="line">            newArr.push(arr[<span class="built_in">i</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...new Set(newArr)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的有点复杂，修改了一下，好像复杂程度也差不多。。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">same</span><span class="params">(arr)</span> &#123;</span></span><br><span class="line">    arr.<span class="built_in">sort</span>();</span><br><span class="line">    let newArr = [];</span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="built_in">i</span>] == arr[<span class="built_in">i</span>+<span class="number">1</span>] &amp;&amp; !newArr.includes( arr[<span class="built_in">i</span>] )) &#123;</span><br><span class="line">            newArr.push(arr[<span class="built_in">i</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：利用sort方法，先使用sort方法将数组排序，再来判断找出重复元素</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span><span class="params">(arr)</span></span>&#123;</span><br><span class="line">    var temp=[];</span><br><span class="line">    arr.<span class="built_in">sort</span>().<span class="built_in">sort</span>(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a===b&amp;&amp;temp.indexOf(a)===<span class="number">-1</span>)&#123;</span><br><span class="line">        temp.push(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三：对数组每一项循环，判断它的第一个位置和最后一个位置只要不一样就是重复值，然后在判断放置重复值的数组有没有这个值</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> res(arr) &#123;</span><br><span class="line">    var temp = <span class="literal">[]</span>;</span><br><span class="line">    arr.for<span class="constructor">Each(<span class="params">function</span> (<span class="params">item</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.index<span class="constructor">Of(<span class="params">item</span>)</span> !== arr.last<span class="constructor">IndexOf(<span class="params">item</span>)</span><span class="operator"> &amp;&amp; </span>temp.index<span class="constructor">Of(<span class="params">item</span>)</span><span class="operator"> === </span>-<span class="number">1</span>) &#123;</span><br><span class="line">            temp.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性结构与树形结构相互转换"><a href="#线性结构与树形结构相互转换" class="headerlink" title="线性结构与树形结构相互转换"></a>线性结构与树形结构相互转换</h3><p>当树形结构的层级越来越深时，操作某一节点会变得越来越费劲，维护成本不断增加。所以线性结构与树形的相互转换变得异常重要。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">树形结构</span></span><br><span class="line"></span><br><span class="line"><span class="string">list</span> <span class="string">=</span> <span class="string">[</span></span><br><span class="line">   <span class="string">&#123;</span> <span class="attr">id:</span> <span class="string">number,</span> <span class="attr">parentId:</span> <span class="string">number,</span> <span class="attr">name:</span> <span class="string">string</span> <span class="string">&#125;,</span> </span><br><span class="line">   <span class="string">&#123;</span> <span class="attr">id:</span> <span class="string">number,</span> <span class="attr">parentId:</span> <span class="string">number,</span> <span class="attr">name:</span> <span class="string">string</span> <span class="string">&#125;,</span></span><br><span class="line"><span class="string">];</span></span><br><span class="line"><span class="string">面的树形结构并不是很完美，当遇到菜单或者分类等业务场景时，每个顶级节点的parentId约定为0，当存在多个顶级节点，显得不是一个完整的树。所以在这类特殊情况下，我们需要构造一个顶级节点。将菜单或者分类的原有顶级节点存储至该节点的children中。</span> <span class="string">所以最后约定顶级节点如下。</span></span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">number,</span>  <span class="string">//</span> <span class="string">数值</span></span><br><span class="line">  <span class="attr">parentId:</span> <span class="string">number,</span>  <span class="string">//</span> <span class="string">数值</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string,</span></span><br><span class="line">  <span class="attr">children:</span> <span class="string">[]</span> <span class="string">||</span> <span class="literal">null</span><span class="string">,</span>  <span class="string">//</span> <span class="string">用数组的方式保存子节点，适合更多业务场景</span>  </span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">线性结构</span></span><br><span class="line"><span class="string">root</span> <span class="string">=</span> <span class="literal">null</span> <span class="string">||</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">id:</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line">  <span class="attr">parentId:</span> <span class="literal">null</span><span class="string">,</span></span><br><span class="line">  <span class="attr">children:</span> <span class="string">[node1,</span> <span class="string">node2,</span> <span class="string">...],</span>  </span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>线性结构转树形结构</strong></p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listConvertTree</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> &amp;&amp; <span class="built_in">list</span>.length) &#123;</span><br><span class="line">        root = &#123;<span class="attribute">id:</span><span class="string"> 0, parent</span>: <span class="literal">null</span>, <span class="attribute">children</span>: [] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> group = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>[i].parentId !== <span class="literal">null</span> &amp;&amp; <span class="built_in">list</span>[i].parentId !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!group[<span class="built_in">list</span>[i].parentId]) &#123;</span><br><span class="line">                group[<span class="built_in">list</span>[i].parentId] = []; <span class="comment">//group=&#123;[]&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            group[<span class="built_in">list</span>[i].parentId].push(<span class="built_in">list</span>[i]); <span class="comment">//group=&#123;[&#123; id: number, parentId: number, name: string &#125; ]&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">        node.children = group[node.id] &amp;&amp; group[node.id].length ? group[node.id] : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">                queue.push(...node.children);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">list</span> = [ </span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">0</span>, <span class="attribute">id:</span><span class="string"> 1, value</span>: <span class="string">'1'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">3</span>, <span class="attribute">id:</span><span class="string"> 2, value</span>: <span class="string">'2'</span> &#125;, </span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">0</span>, <span class="attribute">id:</span><span class="string"> 3, value</span>: <span class="string">'3'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">1</span>, <span class="attribute">id:</span><span class="string"> 4, value</span>: <span class="string">'4'</span> &#125;, </span><br><span class="line">    &#123; <span class="attribute">parentId</span>: <span class="number">1</span>, <span class="attribute">id:</span><span class="string"> 5, value</span>: <span class="string">'5'</span> &#125;, </span><br><span class="line">]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listToTree</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//遍历整个列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>.filter(cur=&gt;&#123; </span><br><span class="line">        <span class="comment">// 获取当前节点的子节点</span></span><br><span class="line">        <span class="keyword">let</span> children= <span class="built_in">list</span>.filter(item=&gt; item.parentId == cur.id ); </span><br><span class="line">        <span class="keyword">if</span>(children.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             cur.children=children;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只返回顶级节点</span></span><br><span class="line">        <span class="keyword">return</span> cur.parentId==<span class="number">0</span>; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔试</category>
      </categories>
  </entry>
  <entry>
    <title>写给自己的话</title>
    <url>/2020/04/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>&emsp;&emsp;每天都是新的开始，做好准备，才能迎接更好的未来。</p>
<a id="more"></a> 

<h3 id="不安"><a href="#不安" class="headerlink" title="不安"></a>不安</h3><p>临近毕业，很多事情不断的涌进脑海。<br>毕设，工作，父母，建筑，学习……<br>仿佛人生到了一个转折点，不再是一个无忧无虑的时刻了。今后的日子应该如何，选择很重要。</p>
<h3 id="建筑-VS-前端"><a href="#建筑-VS-前端" class="headerlink" title="建筑 VS 前端"></a>建筑 VS 前端</h3><p>和朋友聊聊天，说到转行的不易，有多少份简历石沉大海，就有多少次怀疑直击内心。<br>要不要先找到一份建筑的工作让自己安下这颗不稳定的心，以及要不要放手一搏不留退路。</p>
<h3 id="我的选择"><a href="#我的选择" class="headerlink" title="我的选择"></a>我的选择</h3><p>我想要选择放手一搏，既然心是向往的，就不要给自己一个松懈的借口。身边有支持着你的人，如果就这样选择放弃了，回过头，好像都是些可笑的回忆。</p>
<h4 id="心之所及，就是远方"><a href="#心之所及，就是远方" class="headerlink" title="心之所及，就是远方"></a>心之所及，就是远方</h4><p>不抛弃，不放弃，好好做好每一件事，相信自己，就一定可以的！加油！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>网易互娱二面总结</title>
    <url>/2020/05/18/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>网易互娱二面总结，共计十多个问题。</p>
<a id="more"></a>
<h2 id="1-padding设置百分比是相对于谁？"><a href="#1-padding设置百分比是相对于谁？" class="headerlink" title="1.padding设置百分比是相对于谁？"></a>1.padding设置百分比是相对于谁？</h2><p>参照父元素 <strong>宽度</strong> 的元素：padding margin width text-indent</p>
<p>参照父元素 <strong>高度</strong> 的元素：height</p>
<p>参照父元素属性:font-size line-height</p>
<p>特殊：相对定位的时候，top(bottom) left(right)参照的是父元素的内容区域的高度与宽度，而绝对定位的时候参照的是最近的定位元素包含padding的高度与宽度</p>
<p>CSS权威指南中的解释：<br>我们认为，正常流中的大多数元素都会足够高以包含其后代元素（包括外边距），如果一个元素的上下外边距时父元素的height的百分数，就可能导致一个无限循环，父元素的height会增加，以适应后代元素上下外边距的增加，而相应的，上下外边距因为父元素height的增加也会增加，如果循环。</p>
<h2 id="2-line-height相关问题"><a href="#2-line-height相关问题" class="headerlink" title="2.line-height相关问题"></a>2.line-height相关问题</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>line-height:行距，指的是基线之间的距离。</p>
<p>行距 = 上下行间距 + font-size</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p><strong>normal</strong> ：normal其实就是一个值，不过实际值则由浏览器决定，实际值一般在1.0~1.2之间（含两端）浮动。</p>
<p><strong>数字</strong> ： 设置数字表示的是相对font-size的大小。子元素会继承父元素的line-height,各自的行高会根据自己的font-size计算。例如：父元素设置font-size:20px;line-height:2;子元素设置font-size:10px;则父元素的行高为20px * 2 = 40px;子元素的行高为10px * 2 = 20px;</p>
<p><strong>长度</strong>: 设置具体的长度，例如10px;子元素会直接继承这个line-height,例如：父元素设置line-height:20px;则子元素的行高也为20px；</p>
<p><strong>百分比</strong> ：设置百分比，会计算具体的line-height的长度，再继承。例如：父元素设置font-size:20px;line-height:100%;则行高为20px * 100% = 20px;所有子元素的行高也为20px。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>带单位</strong>的行高以及<strong>百分比</strong>，其子元素继承的是<strong>计算值</strong>，如父元素的字体大小为14px，定义行高line-height:2em;则计算值为28px，不会因其子元素改变字体尺寸而改变行高。<br>(例如：父元素14px，子元素12px,那么行高就是28px，子元素虽然字体是12px，行高还是父元素的行高)</p>
<p><strong>不带单位</strong>的行高是<strong>直接继承</strong>，而不是计算值，如父元素字体尺寸为14px，行高line-height:2;子元素字体为12px，不需要再定义行高，他默认的行高为24px。（例如：子元素12px，他的行高是24px,不会继承父元素的28px）</p>
<h2 id="3-一行中既有文字又有图片的对齐方式"><a href="#3-一行中既有文字又有图片的对齐方式" class="headerlink" title="3.一行中既有文字又有图片的对齐方式"></a>3.一行中既有文字又有图片的对齐方式</h2><p>如果一行内容中有图片有文字的话，文字往往会自动的底部对齐，即vertical-align的默认值是baseline。</p>
<p>vertical-align设置行内元素基线和行盒子基线的对齐方式，middle即可垂直居中对齐。</p>
<p>参考链接：<a href="https://juejin.im/entry/5b1a50e95188257d6a044fbc" target="_blank" rel="noopener">https://juejin.im/entry/5b1a50e95188257d6a044fbc</a></p>
<h2 id="4-e-target和e-currentTarget的区别"><a href="#4-e-target和e-currentTarget的区别" class="headerlink" title="4.e.target和e.currentTarget的区别"></a>4.e.target和e.currentTarget的区别</h2><p>e.target指的是触发事件的对象；e.currentTarget指的是绑定事件的元素对象。</p>
<p>事件委托：父元素绑定事件监听，由于事件捕获与冒泡机制，点击子元素也会触发事件，此时的e.target就是当前的子元素，e.currentTarget还是绑定事件的父元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">onclick</span>=<span class="string">"handleClick(event)"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.target); <span class="comment">//当前点击的li</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.currentTarget);<span class="comment">//绑定监听事件的ul</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>参考链接：<a href="https://www.jianshu.com/p/1dd668ccc97a" target="_blank" rel="noopener">https://www.jianshu.com/p/1dd668ccc97a</a></p>
<h2 id="5-let与var的区别，变量提升、函数提升的问题"><a href="#5-let与var的区别，变量提升、函数提升的问题" class="headerlink" title="5.let与var的区别，变量提升、函数提升的问题"></a>5.let与var的区别，变量提升、函数提升的问题</h2><p>ES6 新增了let命令，用来声明局部变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效，而且有暂时性死区的约束。</p>
<p>区别：</p>
<ul>
<li>let与var都是用于声明变量</li>
<li>let不存在<strong>变量提升</strong>，有暂时性死区（在声明前使用变量会报错）</li>
<li>let声明的变量在<strong>代码块内</strong>有效</li>
<li>let<strong>不能重复声明</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">99</span>;            <span class="comment">// 全局变量a</span></span><br><span class="line">f();                   <span class="comment">// f是函数，虽然定义在调用的后面，但是函数声明会提升到作用域的顶部。 </span></span><br><span class="line"><span class="built_in">console</span>.log(a);        <span class="comment">// a=&gt;99,  此时是全局变量的a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);      <span class="comment">// 当前的a变量是下面变量a声明提升后，默认值undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);      <span class="comment">// a =&gt; 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure>

<h2 id="6-什么是闭包"><a href="#6-什么是闭包" class="headerlink" title="6.什么是闭包"></a>6.什么是闭包</h2><p>一、变量的作用域</p>
<p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<p>二、如何从外部读取局部变量？</p>
<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<p>三、闭包的概念</p>
<p>闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>参考链接：<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></p>
<h2 id="7-函数防抖与函数节流"><a href="#7-函数防抖与函数节流" class="headerlink" title="7.函数防抖与函数节流"></a>7.函数防抖与函数节流</h2><p>常见实用场景，有滚动加载、搜索框输入、窗口大小拖拽 Resize。</p>
<h3 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h3><p>函数防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">const <span class="module-access"><span class="module"><span class="identifier">_</span>.</span></span>debounce =<span class="function"> (<span class="params">func</span>, <span class="params">wait</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  return<span class="function"> <span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clear<span class="constructor">Timeout(<span class="params">timer</span>)</span>;</span><br><span class="line">    timer = set<span class="constructor">Timeout(<span class="params">func</span>, <span class="params">wait</span>)</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h3><p>限制一个函数在一定时间内只能执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）函数节流的 setTimeout 版简单实现</span><br><span class="line"><span class="keyword">const</span> _.throttle = <span class="function">(<span class="params">func, wait</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func();</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）函数节流的时间戳版简单实现</span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">func, wait</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current_time = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (current_time - last &gt; wait) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      last = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="函数防抖的应用场景"><a href="#函数防抖的应用场景" class="headerlink" title="函数防抖的应用场景"></a>函数防抖的应用场景</h3><p>连续的事件，只需触发一次回调的场景有：</p>
<ul>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>
</ul>
<h3 id="函数节流的应用场景"><a href="#函数节流的应用场景" class="headerlink" title="函数节流的应用场景"></a>函数节流的应用场景</h3><p>间隔一段时间执行一次回调的场景有：</p>
<ul>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>谷歌搜索框，搜索联想功能</li>
<li>高频点击提交，表单重复提交</li>
</ul>
<h2 id="8-了解前端安全以及防御相关的知识吗？"><a href="#8-了解前端安全以及防御相关的知识吗？" class="headerlink" title="8.了解前端安全以及防御相关的知识吗？"></a>8.了解前端安全以及防御相关的知识吗？</h2><h3 id="XSS（Cross-Site-Scripting）跨站脚本攻击"><a href="#XSS（Cross-Site-Scripting）跨站脚本攻击" class="headerlink" title="XSS（Cross Site Scripting）跨站脚本攻击"></a>XSS（Cross Site Scripting）跨站脚本攻击</h3><ul>
<li>原理：页面渲染的数据中包含可运行的脚本</li>
<li>攻击的基本类型：反射型（url参数直接注入）和存储型（存储到DB后读取时注入）</li>
<li>注入点：HTML节点内的内容（text）；HTML中DOM元素的属性；Javascript代码；富文本</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//HTML节点内容注入</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1);<span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">//DOM属性注入</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'/images/1.png'</span> <span class="attr">onerror</span>=<span class="string">'alert(1);'</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">//javascript代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> a = <span class="string">'1'</span>;alert(<span class="number">1</span>);<span class="string">''</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//富文本是html标签，文字，以及样式的集合，很容易实现HTML节点内容注入和DOM属性注入，有被攻击的风险</span><br></pre></td></tr></table></figure>

<h3 id="CSRF（Cross-Site-Request-Forgy）跨站请求伪造"><a href="#CSRF（Cross-Site-Request-Forgy）跨站请求伪造" class="headerlink" title="CSRF（Cross Site Request Forgy）跨站请求伪造"></a>CSRF（Cross Site Request Forgy）跨站请求伪造</h3><p>原理：在第三方网站向本网站发起请求</p>
<ul>
<li>用户在a站前端页面发起登录（身份认证）请求</li>
<li>a站后端确认身份，登录成功，cookie中存在用户的身份认证信息</li>
<li>b站前端页面向a站后端发起请求，带着a站的cookie信息（身份认证信息），请求成功</li>
</ul>
<p>综上，可以清楚的知道，只要用户访问了b站的前端页面，b站就可以在用户完全不知道的情况下，带着a站的用户登录态（cookie）向a站发起请求</p>
<h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>原理：第三方网站通过iframe内嵌某一个网站，并且将iframe设置为透明不可见，将其覆盖在其他经过伪装的DOM上，伪装的可点击DOM（按钮等）与实际内嵌网站的可点击DOM位置相同，当用户点击伪装的DOM时，实际上点击的是iframe中内嵌的网页的DOM从而触发请求操作</p>
<p>特点：用户自己做了点击操作；用户毫不知情；</p>
<h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><h4 id="XSS攻击防御"><a href="#XSS攻击防御" class="headerlink" title="XSS攻击防御"></a>XSS攻击防御</h4><ul>
<li>浏览器自带防御机制，主要应对反射型攻击（HTML内容或属性）：http响应头中自动添加x-xss-protection，值为0（关闭），1（打开），默认打开</li>
<li>对特定字符做转义：内容注入替换尖括号（ &lt; =&gt; &lt;   &gt; =&gt; &gt; ） 属性注入替换单引号或双引号（ “ =&gt; &quot;  ‘ =&gt; &#39; </li>
<li>CSP（Content Security Policy）内容安全策略：用于指定哪些内容可执行<figure class="highlight csp"><table><tr><td class="code"><pre><span class="line">//我们可以在http响应头中设置Content-Security-Policy</span><br><span class="line">//图片可以从任何地方加载(注意 "*" 通配符)</span><br><span class="line">//多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)</span><br><span class="line">//可运行脚本仅允许来自于userscripts.example.com</span><br><span class="line"><span class="attribute">Content-Security-Policy</span>: <span class="keyword">default-src</span> <span class="string">'self'</span>; <span class="keyword">img-src</span> *; <span class="keyword">media-src</span> media1.com media2.com; <span class="keyword">script-src</span> userscripts.example.com</span><br><span class="line"></span><br><span class="line">//同时meta中也支持设置Content-Security-Policy</span><br><span class="line">&lt;meta http-equiv="Content-Security-Policy" content="<span class="keyword">default-src</span> <span class="string">'self'</span>; <span class="keyword">img-src</span> https://*; <span class="keyword">child-src</span> <span class="string">'none'</span>;"&gt;</span><br></pre></td></tr></table></figure>
<h4 id="CSRF攻击防御："><a href="#CSRF攻击防御：" class="headerlink" title="CSRF攻击防御："></a>CSRF攻击防御：</h4></li>
</ul>
<p>CSRF的发生有几个特点，b站发送的请求带着a站的cookie信息； b站发送请求不经过a站的前端；http请求头中的referer为b站。我们可以从这些特点入手，思考防御的办法</p>
<ul>
<li>禁止第三方网站携带本网站的cookie信息：设置same-site属性，same-site属性有两个值，Strict（所有的第三方请求都不能携带本网站的cookie）和Lax（链接可以，但是form表单提交和ajax请求不行）</li>
<li>本网站前端页面添加验证信息：使用验证码或者添加token验证<ul>
<li>验证码：当发起请求时，前端需要输入本网站页面的验证码信息，后端对验证码进行验证，验证码正确才会进行相关操作（存取数据等）</li>
<li>token验证：a站前端将token存在当前页面中（比如表单中的input隐藏域，meta标签或者任何一个dom的属性）和cookie中，当请求a站后端的时候，参数中带上这个token字段，a站后端将参数中的token和cookie中的token做对比， 相同则验证通过，不同则请求不合法</li>
</ul>
</li>
</ul>
<p>不管是验证码还是token验证，原理都是一样的，在a站前端页面加入验证，当第三方网站请求a站后端时，即使能携带a站cookie，但是因为没有经过a站的前端页面从而拿不到验证信息，也会导致请求失败。</p>
<p>两种防御的方法也有区别，验证码需要用户去填写，从而增加了用户使用网站的复杂度，而token验证在用户无感知的情况下就可以实现，不影响用户体验。我个人理解，验证码验证一般使用在需要提高用户认知的场景，比如，登录多次失败，修改个人信息（用户名，密码，绑定手机号等等），而一些获取商品列表信息，搜索等接口，使用token比较合理。可以看看我们平时使用的这些网站，作参考～</p>
<ul>
<li>referer验证：禁止来自第三方的请求</li>
<li>使用post请求：有一个说法是“post请求比get请求更安全”，那这种说法对不对呢？实际上这种说法并不准确，对于CSRF攻击来讲，不管是post还是get都能实现攻击，区别只是post请求攻击方需要构造一个form表单才可以发起请求，比get请求（img的src， a标签的href等等）的攻击方式复杂了一些，但是并不能有效的阻止攻击。</li>
</ul>
<h4 id="点击劫持攻击防御"><a href="#点击劫持攻击防御" class="headerlink" title="点击劫持攻击防御"></a>点击劫持攻击防御</h4><ul>
<li>Javascript禁止内嵌：当网页没有被使用iframe内嵌时，top和window是相等的；当网页被内嵌时，top和window是不相等的；可以在本网站的页面中添加如下判断：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (top.location != <span class="built_in">window</span>.location) &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//如果不相等，说明使用了iframe，可进行相关的操作</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>设置http响应头 X-Frame-Options：有三个值DENY（禁止内嵌）SAMEORIGIN（只允许同域名页面内嵌） ALLOW-FROM（指定可以内嵌的地址）能在所有的web服务器端预设好X-Frame-Options字段值是最理想的状态。</li>
<li>一些辅助手段，比如添加验证码，提高用户的防范意识</li>
</ul>
<p>b站视频：<a href="https://www.bilibili.com/video/BV1LJ411G7Lp" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1LJ411G7Lp</a></p>
<h2 id="9-Promiss相关"><a href="#9-Promiss相关" class="headerlink" title="9.Promiss相关"></a>9.Promiss相关</h2><p>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(test).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>1)试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以<strong>并行执行</strong>的，用<span style="color:red">Promise.all()</span>实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 同时执行p1和p2，并在它们都完成后执行then:</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// 获得一个Array: ['P1', 'P2']</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>2)有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用<span style="color:red">Promise.race()</span>实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 'P1'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>参考链接：<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544</a></p>
<h2 id="10-了解JavaScript规范吗？ES6？ES7-react版本？？"><a href="#10-了解JavaScript规范吗？ES6？ES7-react版本？？" class="headerlink" title="10.了解JavaScript规范吗？ES6？ES7?react版本？？"></a>10.了解JavaScript规范吗？ES6？ES7?react版本？？</h2><h2 id="11-react是单向数据流，如何实现双向绑定？"><a href="#11-react是单向数据流，如何实现双向绑定？" class="headerlink" title="11.react是单向数据流，如何实现双向绑定？"></a>11.react是单向数据流，如何实现双向绑定？</h2><p>举例说明：input输入框，添加监听事件onChange，每次触发事件时,将e.target.value通过this.setState来修改this.state;</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                <span class="keyword">super</span>();     <span class="comment">//继承关键字</span></span><br><span class="line">                <span class="keyword">this</span>.state = &#123;</span><br><span class="line">                    value: <span class="string">"123456789"</span>    <span class="comment">//设置默认值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            change(e) &#123;</span><br><span class="line">                console.log(e.target.value);    <span class="comment">//获取修改后的值</span></span><br><span class="line">                <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                    value: e.target.value</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//渲染</span></span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">var</span> flag = <span class="keyword">this</span>.state.flag;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;input </span><br><span class="line">                        value=&#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">                        onChange=&#123;(event) =&gt; &#123; <span class="keyword">this</span>.change(event) &#125;&#125; /&gt;</span><br><span class="line">                        &lt;p&gt;&#123;<span class="keyword">this</span>.state.value&#125;&lt;/p&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="12-onChange事件与onInput事件的区别？"><a href="#12-onChange事件与onInput事件的区别？" class="headerlink" title="12.onChange事件与onInput事件的区别？"></a>12.onChange事件与onInput事件的区别？</h2><ul>
<li><strong>onchange</strong>事件仅仅在键盘或者鼠标操作改变对象属性，且失去焦点时触发，脚本触发无效；而onkeydown/onkeypress/onkeyup在处理复制、粘贴、拖拽、长按键（按住键盘不放）等细节上并不完好。</li>
<li><strong>onpropertychange</strong>属性可在某些情况下解决上面存在的问题，不用考虑是否失去焦点。无论js操作还是键盘鼠标手动操作，仅仅要HTML元素属性发生改变就可以马上捕获到。遗憾的是。onpropertychange为IE专属的。</li>
<li><strong>HTML5中的标准事件oninput</strong>，实时监听（和ie的onpropertychange一样），只是IE9下面的浏览器是不支持oninput事件的。</li>
</ul>
<h2 id="13-说出键盘事件以及它们的区别？"><a href="#13-说出键盘事件以及它们的区别？" class="headerlink" title="13.说出键盘事件以及它们的区别？"></a>13.说出键盘事件以及它们的区别？</h2><p>按下松开键盘依次触发事件：onkeydown &gt; onkeypress &gt; onkeyup</p>
<ul>
<li>按下键盘会触发onkeypress和onkeydown，顺序是onkeydown&gt;onkeypress，两者的区别是： <ul>
<li>onkeypress 无法系统按钮。</li>
<li>onkeydown 捕获的 keyCode 不区分字母大小，而 onkeypress 区分(只有onkeypress区分)。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//写一个例子试着打印一下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onkeypress</span>=<span class="string">"handlePress(event)"</span> <span class="attr">onkeydown</span>=<span class="string">"handleDown(event)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  	<span class="function"><span class="keyword">function</span> <span class="title">handlePress</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'onkeypress'</span>+e.keyCode)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">handleDown</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'onkeydown'</span> + e.keyCode)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
按下小写的a：使用中文输入法时，按下a会触发onkeydown事件，不会触发onkeypress事件</li>
</ul>
</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//onkeydown229</span></span><br></pre></td></tr></table></figure>
<p>按下小写的a：使用英文输入法:onkeydown&gt;onkeypress，onkeypress可以识别大小写，onkeydown的keyCode只是大写的值</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//onkeydown65</span></span><br><span class="line"><span class="comment">//onkeypress97</span></span><br></pre></td></tr></table></figure>

<p>参考链接:<a href="https://www.jianshu.com/p/52b904eb9b7b" target="_blank" rel="noopener">https://www.jianshu.com/p/52b904eb9b7b</a></p>
<h2 id="14-redux理解"><a href="#14-redux理解" class="headerlink" title="14.redux理解"></a>14.redux理解</h2><p>在一个使用了 Redux 的 App应用里面会遵循下面四步：</p>
<ul>
<li>第一步：通过store.dispatch(action)来触发一个action，action就是一个描述将要发生什么的对象。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attribute">type</span>: <span class="string">'LIKE_ARTICLE'</span>, articleId: <span class="number">42</span> &#125;</span><br><span class="line">&#123; <span class="attribute">type</span>: <span class="string">'FETCH_USER_SUCCESS'</span>, response: &#123; id: <span class="number">3</span>, name: <span class="string">'Mary'</span> &#125; &#125;</span><br><span class="line">&#123; <span class="attribute">type</span>: <span class="string">'ADD_TODO'</span>, text: <span class="string">'金融前端.'</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li>第二步：Redux会调用你提供的  Reducer函数。</li>
<li>第三步：根 Reducer 会将多个不同的 Reducer 函数合并到单独的状态树中。</li>
<li>第四步：Redux store会保存从根 Reducer 函数返回的完整状态树。</li>
</ul>
<h4 id="reducer为什么要返回一个新的state不能直接修改呢？"><a href="#reducer为什么要返回一个新的state不能直接修改呢？" class="headerlink" title="reducer为什么要返回一个新的state不能直接修改呢？"></a>reducer为什么要返回一个新的state不能直接修改呢？</h4><p>Redux 只通过比较新旧对象的地址来比较两个对象是否相同，也就是通过浅比较。如果在 Reducer 内部直接修改旧的state的属性值，新旧两个对象都指向同一个对象，如果还是通过浅比较，则会导致 Redux 认为没有发生改变。但要是通过深比较，会十分耗费性能。最佳的办法是 Redux返回一个新对象，新旧对象通过浅比较，这也是 Reducer是纯函数的重要原因。</p>
<p>参考链接：<a href="https://juejin.im/post/5e547639e51d4526f65cc313" target="_blank" rel="noopener">https://juejin.im/post/5e547639e51d4526f65cc313</a></p>
<h2 id="15-react传值的方式"><a href="#15-react传值的方式" class="headerlink" title="15.react传值的方式"></a>15.react传值的方式</h2><ul>
<li>父子组件：props、state/callback回调来进行通信</li>
<li>单页面应用：路由传值</li>
<li>全局事件比如EventEmitter监听回调传值</li>
<li>react中跨层级组件数据传递Context（上下文</li>
<li>在小型、不太复杂的应用中，一般用以上几种组件通信方式基本就足够了。但随着应用逐渐复杂，数据状态过多（比如服务端响应数据、浏览器缓存数据、UI状态值等）以及状态可能会经常发生变化的情况下，使用以上组件通信方式会很复杂、繁琐以及很难定位、调试相关问题。因此状态管理框架（如 Vuex、MobX、Redux等）就显得十分必要了，而 Redux 就是其中使用最广、生态最完善的。</li>
</ul>
<h2 id="16-算法题：有一组数，要求找出哪两个数之差最大，必须用index大的数减去index小的数。"><a href="#16-算法题：有一组数，要求找出哪两个数之差最大，必须用index大的数减去index小的数。" class="headerlink" title="16.算法题：有一组数，要求找出哪两个数之差最大，必须用index大的数减去index小的数。"></a>16.算法题：有一组数，要求找出哪两个数之差最大，必须用index大的数减去index小的数。</h2><p>方法一：两次循环，时间复杂度为O(N^2)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">4</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">54</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">77</span>];</span><br><span class="line">var a = arr[<span class="number">0</span>];</span><br><span class="line">var b = arr[<span class="number">1</span>];</span><br><span class="line">var result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (let j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] - arr[i] &gt; result) &#123;</span><br><span class="line">                result = arr[j] - arr[i];</span><br><span class="line">                a = arr[i];</span><br><span class="line">                b = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(`a为$&#123;a&#125;,b为$&#123;b&#125;,结果是$&#123;result&#125;`); <span class="comment">//a为1,b为77,结果是76</span></span><br></pre></td></tr></table></figure>
<p>方法二：用一次循环实现，时间复杂度为O(N)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">4</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">54</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">77</span>]</span><br><span class="line">        var a = arr[<span class="number">0</span>];</span><br><span class="line">        var b = arr[<span class="number">1</span>];</span><br><span class="line">        var result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; a) &#123;</span><br><span class="line">                a = arr[i]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] - a &gt; result) &#123;</span><br><span class="line">                b = arr[i];</span><br><span class="line">                result = b - a</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(`a为$&#123;a&#125;,b为$&#123;b&#125;,结果是$&#123;result&#125;`); <span class="comment">//a为1,b为77,结果是76</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>钉钉微应用开发总结</title>
    <url>/2020/05/11/%E9%92%89%E9%92%89%E5%BE%AE%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>&emsp;&emsp;前一段时间做了一个钉钉微应用，以下对于此次开发进行总结。</p>
<a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本次考核题目是做一个钉钉微应用，看了技术要求，除了前端部分好像都比较陌生，于是只能一边学习一边开发。根据考核要求，使用不同的技术进行开发，先看官方文档，然后跟着文档进行开发。</p>
<h3 id="钉钉微应用"><a href="#钉钉微应用" class="headerlink" title="钉钉微应用"></a>钉钉微应用</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>根据钉钉官网有关微应用的开发文档进行操作，登录开发者后台，点击==应用开发==，创建H5微应用，点击<a href="https://note.youdao.com/" target="_blank" rel="noopener">http://ddns.oray.com/checkip</a>可以查看当前的==服务器出口ip==，填写==应用首页地址==，对应的就是客户端点击进入微应用的界面。创建完成之后，生成的AppKey和AgentId可以获取access_token进行鉴权。</p>
<h4 id="免登"><a href="#免登" class="headerlink" title="免登"></a>免登</h4><p>实现方法：在页面加载时可以通过调用官方的<a href="https://ding-doc.dingtalk.com/doc#/dev/about#hc3esk" target="_blank" rel="noopener">获取免登授权码</a>API，可以实现免登，同时获取用户身份，发送到后端获取对应身份的todolist数据，再返回前端进行显示。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">dd.ready(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dd.runtime.permission.requestAuthCode(&#123;</span><br><span class="line">        corpId: _config.corpId, <span class="comment">// 企业id</span></span><br><span class="line">        onSuccess: <span class="function"><span class="keyword">function</span> <span class="params">(info)</span> </span>&#123;</span><br><span class="line">                  code = info.code <span class="comment">// 通过该免登授权码可以获取用户身份</span></span><br><span class="line">        &#125;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="前端-vue-element-ui"><a href="#前端-vue-element-ui" class="headerlink" title="前端:vue+element ui"></a>前端:vue+element ui</h3><p>根据Todolist的功能，我将微应用分为两个页面，通过==路由==实现页面跳转。<br>一个是用于展示总的todolist，可以勾选是否完成，以及分类查看的页面，另一个是用来编辑和查看详情的页面。</p>
<h4 id="主展示页面"><a href="#主展示页面" class="headerlink" title="主展示页面"></a>主展示页面</h4><p><img src="/.com//1.png" alt></p>
<p>页面主要是上中下结构，使用的是 element ui的==Container 布局容器==进行布局，上下定宽，中间自适应。</p>
<ul>
<li><strong>头部显示时间</strong>：通过==Date==对象的相关api实现。</li>
</ul>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">getDate () &#123;</span><br><span class="line">      <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Date</span>().getMonth() + <span class="number">1</span></span><br><span class="line">      m = m &lt; <span class="number">10</span> ? <span class="string">'0'</span> + <span class="attribute">m</span> : m</span><br><span class="line">      <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>().getDate()</span><br><span class="line">      d = d &lt; <span class="number">10</span> ? <span class="string">'0'</span> + <span class="attribute">d</span> : d</span><br><span class="line">      <span class="keyword">let</span> day = <span class="keyword">new</span> <span class="built_in">Date</span>().getDay()</span><br><span class="line">      day = [<span class="string">'周一'</span>, <span class="string">'周二'</span>, <span class="string">'周三'</span>, <span class="string">'周四'</span>, <span class="string">'周五'</span>, <span class="string">'周六'</span>, <span class="string">'周日'</span>][day]</span><br><span class="line">      <span class="keyword">let</span> <span class="built_in">date</span> = m + <span class="string">'/'</span> + d + <span class="string">' '</span> + day</span><br><span class="line">      <span class="keyword">this</span>.date = <span class="built_in">date</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取todolist数据</strong>：在vue的==create==生命周期函数中，使用==axios==发送请求获取用户的todolist；</li>
<li><strong>todo是否完成</strong>：在页面展示todo的组件中，使用了==Icon、Checkbox==组件，点击复选框勾选todo，表示todo已完成，反之未完成。每次勾选都会发送请求到服务端，修改数据库信息。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用.stop修饰符防止事件冒泡</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"checkbox"</span> @click.stop = <span class="string">"handleCompleted(item)"</span>&gt;</span><br><span class="line">    &lt;el-checkbox v-model=<span class="string">"item.completed"</span> &gt;&lt;<span class="regexp">/el-checkbox&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>筛选todo</strong>：在页面底部，使用==Button==组件，对todolist进行筛选。在data中使用filter记录筛选模式，0代表全部，1代表已完成，2代表未完成。使用==computed计算属性==，用==filter==方法对总的todolist进行筛选，再使用==v-for==将筛选结果循环展示在页面中。</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">//template</span><br><span class="line"><span class="symbol">&lt;el-footer&gt;</span></span><br><span class="line">    &lt;<span class="keyword">el</span>-button <span class="built_in">type</span>=<span class="string">"info"</span> plain  @click=<span class="string">"filter = 0"</span>&gt;全部&lt;/<span class="keyword">el</span>-button&gt;</span><br><span class="line">    &lt;<span class="keyword">el</span>-button <span class="built_in">type</span>=<span class="string">"info"</span> plain @click=<span class="string">"filter = 1"</span>&gt;已完成&lt;/<span class="keyword">el</span>-button&gt;</span><br><span class="line">    &lt;<span class="keyword">el</span>-button <span class="built_in">type</span>=<span class="string">"info"</span> plain  @click=<span class="string">"filter = 2"</span>&gt;未完成&lt;/<span class="keyword">el</span>-button&gt;</span><br><span class="line">  &lt;/<span class="keyword">el</span>-footer&gt;</span><br><span class="line">  </span><br><span class="line">  //script</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 筛选toto</span><br><span class="line">    filterTodo: <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mode</span> = this.<span class="built_in">filter</span></span><br><span class="line">      <span class="keyword">let</span> todos = this.todo</span><br><span class="line">      // 如果不是全部，则判断是筛选完成还是未完成，返回对应数据</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">mode</span>) &#123;</span><br><span class="line">        todos = todos.<span class="built_in">filter</span>(item =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">mode</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> item.completed</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !item.completed</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> todos</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>删除toodo</strong>：长按todo项，会弹出删除和取消的按钮，添加==touchstart==事件，使用定时器==setTimeout==定时弹出按钮。==v-show==来控制按钮的显隐。点击删除按钮，将todoid和userid作为params，并发送对应的请求到服务端，服务端根据userid和todoid再对数据库进行删除操作。删除之后再次请求就可以拿到最新的todolist数据，再进行前面的操作展示页面。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作按钮代码，使用v-show来控制显隐</span></span><br><span class="line">    &lt;ul <span class="keyword">class</span>=<span class="string">"operate"</span> v-show=<span class="string">"item.operateVisible"</span>&gt;</span><br><span class="line">        &lt;li @click.stop=<span class="string">"deleteTodo(item)"</span>&gt;删除&lt;/li&gt;</span><br><span class="line">        &lt;li @click.stop=<span class="string">"item.operateVisible = false"</span>&gt;取消&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为todoitem添加touchstart、touchend、touchmove事件后</span></span><br><span class="line">    </span><br><span class="line">    gotouchstart (item) &#123;</span><br><span class="line">      clear<span class="constructor">Timeout(<span class="params">timeOutEvent</span>)</span> <span class="comment">// 清除定时器</span></span><br><span class="line">      timeOutEvent = <span class="number">0</span></span><br><span class="line">      timeOutEvent = set<span class="constructor">Timeout(<span class="params">function</span> ()</span> &#123;</span><br><span class="line">      <span class="comment">// 执行长按要执行的内容，显示操作按钮</span></span><br><span class="line">        item.operateVisible = <span class="literal">true</span></span><br><span class="line">      &#125;, <span class="number">600</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    gotouchend <span class="literal">()</span> &#123;</span><br><span class="line">      clear<span class="constructor">Timeout(<span class="params">timeOutEvent</span>)</span></span><br><span class="line">      <span class="keyword">if</span> (timeOutEvent !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里写要执行的内容（尤如onclick事件）</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    gotouchmove <span class="literal">()</span> &#123;</span><br><span class="line">      clear<span class="constructor">Timeout(<span class="params">timeOutEvent</span>)</span> <span class="comment">// 清除定时器</span></span><br><span class="line">      timeOutEvent = <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    deleteTodo (item) &#123;</span><br><span class="line">      <span class="comment">//隐藏操作按钮</span></span><br><span class="line">      item.operateVisible = <span class="literal">false</span></span><br><span class="line">      <span class="comment">// 删除数据</span></span><br><span class="line">      delete<span class="constructor">TodoList('<span class="operator">/</span><span class="params">delete</span>', &#123;<span class="params">id</span>: <span class="params">item</span>.<span class="params">id</span>&#125;)</span></span><br><span class="line">      <span class="comment">// 重新获取数据渲染</span></span><br><span class="line">      this.get<span class="constructor">Todo()</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="编辑页面"><a href="#编辑页面" class="headerlink" title="编辑页面"></a>编辑页面</h4><p><img src="/.com//2.png" alt></p>
<p>编辑页面和展示详情的页面是同一个页面。主页面中点击每一项todo或者点击右下角的+可以跳转到编辑页面，同时通过==路由传参==传递userid和todoid。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span> <span class="selector-tag">new</span> <span class="selector-tag">Router</span>(&#123;</span><br><span class="line">  <span class="attribute">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// todo首页</span></span><br><span class="line">      <span class="attribute">path</span>: <span class="string">'/'</span>,</span><br><span class="line">      <span class="attribute">name</span>: <span class="string">'Todo'</span>,</span><br><span class="line">      <span class="attribute">component</span>: Todo</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      <span class="comment">// todo编辑/查看页面</span></span><br><span class="line">      <span class="attribute">path</span>: <span class="string">'/edit'</span>,</span><br><span class="line">      <span class="attribute">name</span>: <span class="string">'Edit'</span>,</span><br><span class="line">      <span class="attribute">component</span>: Edit</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>组件选用</strong>：编辑页面使用了==Input==输入框、==Select==选择器、==DatePicker== 日期选择器、==Upload==上传组件，在原有组件的基础上进行css的修改。</p>
</li>
<li><p><strong>选择参与同事</strong>：可以使用平台提供的的接口==dd.biz.contact.complexPicker==通过钉钉通讯录选择参与同事。目前是使用的一个下拉框代替选择功能。</p>
</li>
<li><p><strong>判断是修改查看还是新增</strong>：在编辑页面的==create==函数中中，拿到路由传递的参数并进行判断，如果为空，则表示为添加todo，如果有参数，则表示为查看详情，此时再向服务端发送请求，获取对应的todo详情并进行展示。</p>
</li>
<li><p><strong>新增或修改</strong>：点击保存按钮，首先判断路由传递的参数，如果为空，则表示此项todo为新增，则将userid和todoid作为params，调用添加todo的接口；如果有参数，就调用修改todo的接口。</p>
</li>
</ul>
<h3 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h3><p>下载安装数据库并进行配置，使用workbench进行图形化管理，创建表格，添加columns。</p>
<h3 id="后端：egg-js"><a href="#后端：egg-js" class="headerlink" title="后端：egg.js"></a>后端：egg.js</h3><p>根据egg.js的官方文档进行开发，首先使用脚手架搭建一个egg.js项目。然后再安装==egg-mysql==插件，配置好数据库。</p>
<p>首先在router.js中定义路由规则，再在controller中定义对应方法，service中去访问SQL数据库并对数据进行操作，然后返回结果。</p>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>因为同源策略，此时前端无法请求到数据，可以使用nginx用来==反向代理==，就可以实现前端向后端发起请求了。在nginx.conf配置文件中增加配置：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">        <span class="keyword">listen</span>       <span class="number">8080</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">location</span> /<span class="keyword">get</span> &#123;</span><br><span class="line">            proxy_pass <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7001</span>;</span><br><span class="line">            <span class="keyword">index</span>  <span class="keyword">index</span>.html <span class="keyword">index</span>.htm <span class="keyword">index</span>.jsp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于服务端以及部署相关内容第一次接触，所以总的开发进度较慢。暂时呈现的页面也有很多不足的地方，比如在长按todo的时候会选中文字，弹出的删除按钮可能使用钉钉微应用提供的弹框(dd.device.notification.confirm)会更好。希望以后的开发中，能够注意细节和体验。</p>
<p>通过此次的练习，我对有关钉钉微应用API的JSAPI有了初步的了解，对钉钉微应用的开发流程有了进一步的认识，以后对于微应用的开发会也更加熟练啦~如果有前辈们的指点，相信我能够做得更好的！！</p>
]]></content>
      <categories>
        <category>微应用</category>
      </categories>
      <tags>
        <tag>微应用</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
</search>
