<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6相关知识点</title>
    <url>/2020/04/05/ES6/</url>
    <content><![CDATA[<p>今天来复习一下ES6的相关知识吧，打好每一个基础吧。那么开始吧</p>
<a id="more"></a> 

<h2 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul>
<li><p>代码块内有效</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&#123;let a = <span class="number">0</span>; var b = <span class="number">2</span>&#125; a <span class="comment">// 报错 ReferenceError: a is not defined b // 2</span></span><br></pre></td></tr></table></figure>
<p>  在代码块内，let声明的是局部变量；var声明的是全局变量</p>
</li>
<li><p>不能重发声明</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let a = <span class="number">1</span>; let a = <span class="number">2</span>; var b = <span class="number">3</span>; var b = <span class="number">4</span>; a  <span class="comment">// Identifier 'a' has already been declared b  // 4</span></span><br></pre></td></tr></table></figure>
<p>for循环很适合用let，var声明的i是全局变量，因此外部的i等于最后一次i的值。<br>let声明的i在每轮循环中都是新的变量。</p>
</li>
<li><p>let不存在变量提升</p>
</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li><code>const</code>声明一个只读变量，声明之后不允许改变，一旦声明必须初始化，否则会报错</li>
<li>暂时性死区<ul>
<li><code>const</code>和<code>let</code>一样，都是局部作用域的，因此在声明之前使用变量会报错。</li>
</ul>
</li>
<li>注意：<code>const</code>声明之后允许改变。<ul>
<li>简单数据类型，就是值不许改变。</li>
<li>复杂数据类型，是指向数据的指针不发生改变，数据结构可以改变，所以复杂数据类型要慎用。</li>
</ul>
</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="解构模型"><a href="#解构模型" class="headerlink" title="解构模型"></a>解构模型</h3><ul>
<li>解构的源：右边部分</li>
<li>解构的目标：左边部分<h3 id="数组模型的解构（Array）"><a href="#数组模型的解构（Array）" class="headerlink" title="数组模型的解构（Array）"></a>数组模型的解构（Array）</h3></li>
<li>基本<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// a=1,b=2,c=3</span></span><br></pre></td></tr></table></figure></li>
<li>可嵌套<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">let[a,<span class="string">[[b]，c]]</span> = [<span class="number">1</span>,<span class="string">[[2],3]]</span>;</span><br><span class="line">// a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li>可忽略<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [a, ,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//a = 1; b = 3</span></span><br></pre></td></tr></table></figure></li>
<li>不完全解构<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">1</span>, b] = [ ];</span><br><span class="line">// <span class="attr">a</span> = <span class="number">1</span> ; <span class="attr">b</span> = undefined;</span><br></pre></td></tr></table></figure></li>
<li>剩余运算符<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// a = 1; b = [2, 3]</span></span><br></pre></td></tr></table></figure></li>
<li>字符串等<br>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现iterator接口的数据。<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="regexp">//</span>a = <span class="string">'h'</span>; b = <span class="string">'e'</span>; c = <span class="string">'l'</span>; d = <span class="string">'l'</span>; e = <span class="string">'o'</span></span><br></pre></td></tr></table></figure></li>
<li>解构默认值<br>当解构模式有匹配结果，且匹配结果是undefined时，会触发默认值作为返回结果。<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">1</span>] = [undefined]；</span><br><span class="line">//<span class="attr">a</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = a] = [];     // <span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = a] = [<span class="number">1</span>];    // <span class="attr">a</span> = <span class="number">1</span>, <span class="attr">b</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">a</span> = <span class="number">3</span>, <span class="attr">b</span> = a] = [<span class="number">1</span>, <span class="number">2</span>]; // <span class="attr">a</span> = <span class="number">1</span>, <span class="attr">b</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="对象模型的解构（Object）"><a href="#对象模型的解构（Object）" class="headerlink" title="对象模型的解构（Object）"></a>对象模型的解构（Object）</h3></li>
<li>基本<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> &#125;; <span class="regexp">//</span> foo = <span class="string">'aaa'</span> <span class="regexp">//</span> bar = <span class="string">'bbb'</span> </span><br><span class="line">let &#123; baz : foo &#125; = &#123; baz : <span class="string">'ddd'</span> &#125;; <span class="regexp">//</span> foo = <span class="string">'ddd'</span></span><br></pre></td></tr></table></figure></li>
<li>可嵌套可忽略<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">let obj = &#123;<span class="string">p:</span> [<span class="string">'hello'</span>, &#123;<span class="string">y:</span> <span class="string">'world'</span>&#125;] &#125;; let &#123;<span class="string">p:</span> [x, &#123; y &#125;] &#125; = obj; <span class="comment">// x = 'hello' // y = 'world' </span></span><br><span class="line">let obj = &#123;<span class="string">p:</span> [<span class="string">'hello'</span>, &#123;<span class="string">y:</span> <span class="string">'world'</span>&#125;] &#125;; let &#123;<span class="string">p:</span> [x, &#123;  &#125;] &#125; = obj; <span class="comment">// x = 'hello'</span></span><br></pre></td></tr></table></figure></li>
<li>不完全解构</li>
<li>剩余运算符</li>
<li>默认解构值</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ES6引入新的原始数据类型Symbol，表示独一无二的值，类似字符串，常用作对象的属性名。<br>允许添加一个参数，作为标识。参数相同值也不相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">"KK"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sy);    <span class="comment">//Symbol(KK)</span></span><br><span class="line"><span class="keyword">typeof</span>(sy);  <span class="comment">// symbol</span></span><br><span class="line">相同参数symbol() 返回的值不相等。</span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">"KK"</span>);</span><br><span class="line">sy === sy1;   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h3><p>由于每个Symbol的值都不相等，因此可以用作对象的属性名。以前都是用字符串。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sy</span> = Symbol(<span class="string">"key1"</span>);</span><br><span class="line"></span><br><span class="line">写法<span class="number">1</span>   </span><br><span class="line"><span class="keyword">let</span> <span class="attr">syObj</span> = &#123;&#125;;</span><br><span class="line">    syObj[sy] = <span class="string">"kk"</span>;</span><br><span class="line">    console.log(syObj);    </span><br><span class="line">    // &#123;Symbol(key1) : <span class="string">"kk"</span>&#125;</span><br><span class="line"></span><br><span class="line">写法二   </span><br><span class="line"><span class="keyword">let</span> <span class="attr">syObj</span> = &#123;</span><br><span class="line">  ​  [sy]: <span class="string">"kk"</span>                 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">写法三    </span><br><span class="line"><span class="keyword">let</span> <span class="attr">syObj</span> = &#123;</span><br><span class="line">  ​  Object.defineProperty(syObj,sy,&#123;value:<span class="string">"kk&#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意：Symbol作为对象属性名时不能用  <strong>.</strong> 运算符，要用 <strong>[]</strong>，因为.运算符后面跟字符串，取到的是字符串属性。</p>
<h3 id="如何访问Symbol作为属性名的属性"><a href="#如何访问Symbol作为属性名的属性" class="headerlink" title="如何访问Symbol作为属性名的属性"></a>如何访问Symbol作为属性名的属性</h3><p>不会出现在 for…in 、 for…of 的循环中，也不会被·<code>Object.keys() 、 Object.getOwnPropertyNames()</code>返回。如果要读取到一个对象的 Symbol 属性，可以通过<code>Object.getOwnPropertySymbols()</code>和 <code>Reflect.ownKeys()</code>取到。</p>
<h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h3><p>Symbol.for(),首先会在全局搜索被登记的Symbol中是否有该字符串参数作为名称的Symbol值，如果有即返回该Symbol值，如果没有就会创建一个Symbol值并登记。</p>
<h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h3><p>返回一个已登记的Symbol类型值的key，用来检测该字符串参数作为名称的Symbol值是否已被登记。</p>
<h2 id="Map与Set"><a href="#Map与Set" class="headerlink" title="Map与Set"></a>Map与Set</h2><h3 id="Map对象"><a href="#Map对象" class="headerlink" title="Map对象"></a>Map对象</h3><ul>
<li>Map对象与Object对象的异同<ul>
<li>都是由键值对组成的</li>
<li>Map的键可以是任意类型，Object的键只能是字符串或Symbol</li>
<li>Map中的键值是有序的，Object的不是</li>
<li>Map的键值对个数可以从size属性中获取，Object只能手动计算</li>
<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突</li>
</ul>
</li>
<li>增删改查<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();  <span class="comment">//创建</span></span><br><span class="line">myMap.<span class="keyword">set</span>(<span class="string">"string"</span>,<span class="string">"相关的值"</span>)  <span class="comment">//添加键值对</span></span><br><span class="line">myMap.<span class="keyword">get</span>(<span class="string">"string"</span>)  <span class="comment">//   获取对应key的值 </span></span><br><span class="line">myMap.has(<span class="string">"string"</span>)   <span class="comment">//是否存在key“string”  ：true</span></span><br><span class="line">myMap.delete(<span class="string">"string"</span>)  <span class="comment">//删除key“string”</span></span><br></pre></td></tr></table></figure></li>
<li>Map中的key<ul>
<li>字符串</li>
<li>对象  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var obj =&#123; &#125;; myMap.<span class="builtin-name">get</span>(obj) !== myMap.<span class="builtin-name">get</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>函数<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">fun</span> =<span class="title">function</span> <span class="params">()</span></span>&#123; &#125;; myMap.<span class="keyword">get</span>(<span class="function"><span class="keyword">fun</span>) !== myMap.<span class="title">get</span><span class="params">(function()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>NaN<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var myNaN= NaN; myMap.<span class="builtin-name">get</span>(myNaN) === myMap.<span class="builtin-name">get</span>(Number(<span class="string">"string"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Set对象"><a href="#Set对象" class="headerlink" title="Set对象"></a>Set对象</h3></li>
</ul>
</li>
<li>Set对象允许存储任何类型的唯一值 。</li>
<li>Set中的特殊值<ul>
<li>+0和-0是恒等的，所以不重复</li>
<li>undefined与undefined是恒等的，不重复</li>
<li>NaN与Nan是不恒等的，但在Set中只能存在一个</li>
</ul>
</li>
<li>Set设置与读取<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">let mySet = <span class="built_in">new</span> <span class="keyword">Set</span>();</span><br><span class="line">mySet.<span class="keyword">add</span>(<span class="number">1</span>);  //<span class="keyword">Set</span>(<span class="number">1</span>)&#123;<span class="number">1</span>&#125;</span><br><span class="line">mySet.<span class="keyword">delete</span>(<span class="number">1</span>) 删除</span><br></pre></td></tr></table></figure></li>
<li>应用<ul>
<li>数组去重<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var mySet = new Set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">[...mySet];  <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li>
<li>并集<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="keyword">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="keyword">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]); </span><br><span class="line"><span class="keyword">var</span> <span class="keyword">union</span> = <span class="keyword">new</span> <span class="keyword">Set</span>([...a, ...b]); <span class="comment">// &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>交集<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line">var b = <span class="keyword">new</span> <span class="constructor">Set([4, 3, 2])</span>; </span><br><span class="line">var intersect = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; <span class="params">b</span>.<span class="params">has</span>(<span class="params">x</span>)</span>)); <span class="comment">// &#123;2, 3&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>差集<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line">var b = <span class="keyword">new</span> <span class="constructor">Set([4, 3, 2])</span>; </span><br><span class="line">var difference = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; !<span class="params">b</span>.<span class="params">has</span>(<span class="params">x</span>)</span>)); <span class="comment">// &#123;1&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="正则表达式-regular-expression"><a href="#正则表达式-regular-expression" class="headerlink" title="正则表达式(regular expression)"></a>正则表达式(regular expression)</h2><p>使用场景：匹配（验证用户名、邮箱啊）、替换敏感词、提取文字啊。。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/</span>);</span><br><span class="line"><span class="keyword">var</span> rg1 = <span class="regexp">/abc/</span>;</span><br></pre></td></tr></table></figure>

<p>一共两种方式，正则表达式必须写在<code>/  /</code>之间。不需要用<code>&#39;   &#39;</code>将字符串包起来。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">rg.test(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<p>正则表达式<code>.test（检测内容）</code>    返回<code>ture</code>、<code>false</code></p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>就是指的特殊字符<br>/abc/只要有abc 连在一起就可以</p>
<h4 id="边界符"><a href="#边界符" class="headerlink" title="边界符^   $"></a>边界符^   $</h4><ul>
<li><p>^表示以。。。开头   /^abc/  必须以abc开头</p>
</li>
<li><p>$表示以。。。结尾   /abc$/  必须以abc结尾</p>
</li>
<li><p>^  $ 表示精确匹配     /^abc$/  必须是abc才是true</p>
<h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类[ ]"></a>字符类[ ]</h4></li>
<li><p><code>[ ]</code>表示只能多选一。或者的关系<br> <code>/[abc]/</code>  只要包含有a 或者 包含有 b 或者 包含有c 就可以<br> <code>/^[abc]$/</code>  三选一，只要是有a 或者b 或者c 这三个字母才返回</p>
</li>
<li><p><code>[ - ]</code><br> <code>/^[a-z]$/</code>  26个英文字母任何一个字母就可以，必须是英文</p>
</li>
<li><p>字符组合<br> <code>/^[a-zA-Z0-9_-]$/</code></p>
</li>
<li><p>^取反<br> <code>/^[ ^ 123]$/</code>  <code>[ ]</code>内部的<code>^</code>表示取反，不能有里面的内容</p>
<h4 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h4></li>
<li><p>*相当于&gt;=0  可以出现0次或很多次</p>
</li>
<li><p>+相当于&gt;=1  可以出现1次或很多次</p>
</li>
<li><p>?相当于1||0      0次或者1次</p>
</li>
<li><p>{3}就是重复3次  / ^a{3}$/</p>
</li>
<li><p>{3,} 就是大于等于3</p>
</li>
<li><p>{3,16} 大于等于3，小于等于16</p>
</li>
<li><p><code>/^[a-zA-Z0-9_-]{6,16}$/</code>表示6-16位之间，必须从里面去选择</p>
</li>
<li><p><code>/^abc$/</code> 必须是abc</p>
</li>
<li><p><code>/^[abc]$/</code>  a或b或c</p>
</li>
<li><p><code>/^a{3}$/</code>  必须是aaa</p>
</li>
<li><p><code>/^abc{3}$/</code>  必须是abccc</p>
</li>
<li><p><code>/^(abc){3}$/</code>  abcabcabc </p>
</li>
<li><p>{ } 表示多少次</p>
</li>
<li><p>[ ]表示多选一</p>
</li>
<li><p>( )表示优先级</p>
<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3></li>
<li><p>某些模式的简写方式</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code></li>
<li><code>\D</code> 匹配0-9以外的字符，相当于<code>[ ^ 0-9]</code></li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[a-zA-Z0-9_]</code></li>
<li><code>\W</code> 除所有字母数字和下划线以外的字符，相当于<code>[ ^a-zA-Z0-9]</code></li>
<li><code>\s</code>  匹配空格（包括换行符、制表符、空格符等），相当于<code>[\t\r\n\v\f]</code></li>
<li><code>\S</code>匹配非空格的字符，相当于[ ^\t\r\n\v\f]</li>
</ul>
</li>
<li><p><code>/\w{6,16}/</code></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3></li>
<li><p>座机号码 两种格式：<code>010-12345678</code>  <code>0120-1234567</code><br><code>/\d{3}-\d{8}|\d{4}-\d{7}/</code></p>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>replace(原内容，新内容)</code></p>
</li>
<li><p><code>replace(/激情/，&quot;**&quot;)</code></p>
</li>
<li><p>/表达式/[switch]</p>
<ul>
<li>g  全局匹配 replace(/激情/g,’**’)   replace(/激情|gay/g,’ * *’)</li>
<li>i  忽略大小写</li>
<li>gi 全局匹配和忽略大小写</li>
</ul>
</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const fn = <span class="function"><span class="params">(name)</span>=&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;<span class="attr">name</span>:<span class="string">"张三"</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">​		<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">​	  <span class="keyword">return</span> <span class="function"><span class="params">( )</span> =&gt;</span> &#123;</span><br><span class="line">​		    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">​	  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  resFn = fn.call(obj);</span><br><span class="line">resFn();</span><br></pre></td></tr></table></figure>
<p>// 第一个this是obj对象，第二个this也是obj对象。<br><strong>箭头函数不绑定this关键字，箭头函数的this，指向的是函数定义位置的上下文this</strong>。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">​     age:<span class="number">20</span>;</span><br><span class="line">​			say:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">​				<span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">​			&#125;</span><br><span class="line">​	&#125;</span><br><span class="line">obj.say()  <span class="regexp">//</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>因为箭头函数定义在obj对象里，但是obj对象不能产生作用域，因此，箭头函数被定义在全局作用域下。this指向Window，所以是window对象下的age。如果此时有 var age = 100；则输出装值为100.</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>在箭头函数中，没有arguments哦~~</p>
<ul>
<li>收集剩余的参数，<strong>只能放在末尾</strong>！！！</li>
<li>展开数组，展开后的效果，就跟把数组的内容之间写在这儿一样。<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">sum</span> = (...<span class="keyword">args</span>) =&gt; &#123;</span><br><span class="line">  let <span class="keyword">total</span> = 0;</span><br><span class="line">  <span class="keyword">args</span>.<span class="keyword">forEach</span>(item =&gt; <span class="keyword">total</span> + item )</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">total</span> ;</span><br><span class="line">​&#125;</span><br><span class="line"><span class="built_in">sum</span>(10,20);</span><br><span class="line"><span class="built_in">sum</span>(10,20,30)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h2><p>详情见<a href="https://www.runoob.com/w3cnote/es6-reflect-proxy.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>一个 Proxy 对象由两个部分组成： <strong>target</strong> 、 <strong>handler</strong> 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, key) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getting '</span>+key);</span><br><span class="line">        <span class="keyword">return</span> target[key]; <span class="comment">// 不是target.key</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(target, key, value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setting '</span>+key);</span><br><span class="line">        target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">proxy.name     <span class="comment">// 实际执行 handler.get</span></span><br><span class="line">proxy.age = <span class="number">25</span> <span class="comment">// 实际执行 handler.set</span></span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// setting age</span></span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// target 可以为空对象</span></span><br><span class="line"><span class="keyword">let</span> targetEpt = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEpt = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEpt, handler)</span><br><span class="line"><span class="comment">// 调用 get 方法，此时目标对象为空，没有 name 属性</span></span><br><span class="line">proxyEpt.name <span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// 调用 set 方法，向目标对象中添加了 name 属性</span></span><br><span class="line">proxyEpt.name = <span class="string">'Tom'</span></span><br><span class="line"><span class="comment">// setting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"><span class="comment">// 再次调用 get ，此时已经存在 name 属性</span></span><br><span class="line">proxyEpt.name</span><br><span class="line"><span class="comment">// getting name</span></span><br><span class="line"><span class="comment">// "Tom"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相</span></span><br><span class="line"><span class="comment">// 影响</span></span><br><span class="line">targetEpt)</span><br><span class="line"><span class="comment">// &#123;name: "Tom"&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象</span></span><br><span class="line"><span class="keyword">let</span> targetEmpty = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyEmpty = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetEmpty,&#123;&#125;)</span><br><span class="line">proxyEmpty.name = <span class="string">"Tom"</span></span><br><span class="line">targetEmpty) <span class="comment">// &#123;name: "Tom"&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实例方法</li>
</ul>
<p><strong>get(target, propKey, receiver)</strong><br>用于 target 对象上 propKey 的读取操作。get() 方法可以继承。<br><strong>set(target, propKey, value, receiver)</strong><br>用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。<br><strong>apply(target, ctx, args)</strong><br>用于拦截函数的调用、call 和 reply 操作。target 表示目标对象，ctx 表示目标对象上下文，args 表示目标对象的参数数组。<br><strong>has(target, propKey)</strong><br>用于拦截 HasProperty 操作，即在判断 target 对象是否存在 propKey 属性时，会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。</p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p><strong>Reflect.get(target, name, receiver)</strong><br>查找并返回 target 对象的 name 属性。<br><strong>Reflect.set(target, name, value, receiver)</strong><br>将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错。<br><strong>Reflect.has(obj, name)</strong><br>是 name in obj 指令的函数化，用于查找 name 属性在 obj 对象中是否存在。返回值为 boolean。如果 obj 不是对象则会报错 TypeError。<br><strong>Reflect.deleteProperty(obj, property)</strong><br>是 delete obj[property] 的函数化，用于删除 obj 对象的 property 属性，返回值为 boolean。如果 obj 不是对象则会报错 TypeError。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题优化配置</title>
    <url>/2020/04/06/Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天使用Hexo搭了一个博客，在不断优化过程中去不断的搜集教程，在这里我把自己使用到的方面记录下来，方便今后的查阅。</p>
<a id="more"></a>
<h2 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h2><p>在写博客的过程中，对markdown语法还不是特别熟悉，记录几个语法吧。</p>
<h3 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">半方大的空白   <span class="symbol">&amp;ensp;</span>  或  <span class="symbol">&amp;#8194;</span></span><br><span class="line">全方大的空白   <span class="symbol">&amp;emsp;</span>  或  <span class="symbol">&amp;#8195;</span></span><br><span class="line">不断行的空白格 <span class="symbol">&amp;nbsp;</span>  或  <span class="symbol">&amp;#160;</span></span><br></pre></td></tr></table></figure>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内式链接形式：[<span class="string">超链接文字</span>](<span class="link">url</span>) </span><br><span class="line">[百度]https://www.baidu.com)</span><br></pre></td></tr></table></figure>
<p><strong>在新窗口打开页面</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"/work/manager/index.html"</span> <span class="attribute">target</span>=<span class="string">"_blank"</span>&gt;共享单车后台管理系统&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p><a href="/work/manager/index.html" target="_blank">共享单车后台管理系统</a></p>
<h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(<span class="number">1</span>.jpg)  <span class="comment">//图片放在与文章同名的文件夹中</span></span><br></pre></td></tr></table></figure>
<h3 id="文字颜色"><a href="#文字颜色" class="headerlink" title="文字颜色"></a>文字颜色</h3><p>这是<label style="color:red">红色</label>字体</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">这是&lt;<span class="built_in">label</span> <span class="built_in">style</span>=<span class="string">"color:red"</span>&gt;红色&lt;/<span class="built_in">label</span>&gt;字体</span><br></pre></td></tr></table></figure>
<h2 id="Next主题优化"><a href="#Next主题优化" class="headerlink" title="Next主题优化"></a>Next主题优化</h2><h3 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h3><p>&emsp;&emsp;在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 <strong>阅读全文</strong> 按钮，可以通过以下方法：<br>1.在文章中使用<code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo 提供的方式<br>2.在文章的 <code>front-matter</code> 中添加 <code>description</code>，并提供文章摘录<br>3.自动形成摘要，在 <strong>主题配置文件</strong> 中添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>
<p>默认截取的长度为 150 字符，可以根据需要自行设定</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo过程中遇到的坑</title>
    <url>/2020/04/04/hexo%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天突然心血来潮，想要自己搭建一个博客，正好可以将以前的笔记给系统整理一下。我的博客是使用<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>进行搭建的，跟着网上的教程一步一步的来，却不曾想老是碰见一些问题，不得不去查了好多资料来。在这里就记录几个自己在使用hexo过程中遇到的问题以及记录一下解决的方法。</p>
<a id="more"></a> 

<h2 id="各种问题"><a href="#各种问题" class="headerlink" title="各种问题"></a>各种问题</h2><h3 id="本地测试的时候刷新无效"><a href="#本地测试的时候刷新无效" class="headerlink" title="本地测试的时候刷新无效"></a>本地测试的时候刷新无效</h3><p>优化主题时，修改文件根目录下的<code>_config.yml</code>站点配置目录后，要重新启动Hexo再刷新，修改next主题目录下的<code>_config.yml</code>主题配置目录则只需刷新即可.</p>
<h3 id="使用npm安装插件报错"><a href="#使用npm安装插件报错" class="headerlink" title="使用npm安装插件报错"></a>使用npm安装插件报错</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> ERR! Cannot read property <span class="string">'match'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">npm</span> ERR! A complete log <span class="keyword">of</span> <span class="keyword">this</span> run can be found in:</span><br><span class="line"><span class="built_in">npm</span> ERR!     C:\Users\Administrator\AppData\Roaming\<span class="built_in">npm</span>-cache\_logs\<span class="number">2020</span><span class="number">-04</span><span class="number">-04</span>T12_05_08_782Z-debug.log</span><br></pre></td></tr></table></figure>

<p><code>npm cache clear --force</code>   清除npm本地缓存<br>如果不行，就删除 <code>package-lock.json</code> （这两个办法能够解决我目前遇到的这种情况）<br>再不行的话，就依次执行以下代码：<br>    <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rm</span> <span class="string">-rf node_modules</span></span><br><span class="line"><span class="attr">rm</span> <span class="string">package-lock.json</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">cache clear --force</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure></p>
<h3 id="hexo-helper-live2d相关报错"><a href="#hexo-helper-live2d相关报错" class="headerlink" title="hexo-helper-live2d相关报错"></a>hexo-helper-live2d相关报错</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>Plugin load failed: hexo-helper-live2d</span><br><span class="line"><span class="keyword">Error: </span>Cannot find module 'live2d-widget/lib/manifest'</span><br><span class="line">Require stack:</span><br></pre></td></tr></table></figure>
<p>想要放一个2d模型来着，于是乎跟着教程一边做着，就是运行不起来，最后连正常的页面都显示不了<br>最后通过上一个问题的方法，再加上 <code>hexo clean</code> 解决</p>
<h3 id="hexo-s-报错"><a href="#hexo-s-报错" class="headerlink" title="hexo s 报错"></a>hexo s 报错</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">FATAL bad indentation <span class="keyword">of</span> a <span class="keyword">mapping</span> entry at <span class="type">line</span> <span class="number">103</span>, <span class="keyword">column</span> <span class="number">7</span>:</span><br><span class="line">      <span class="keyword">type</span>: git</span><br><span class="line">          ^</span><br></pre></td></tr></table></figure>
<p>这种问题就是常见的语法错误啦，属性的后面应该跟 <code>英文字符的冒号</code>，再跟值</p>
<h3 id="文章中设置超链接跳转到本地html文件"><a href="#文章中设置超链接跳转到本地html文件" class="headerlink" title="文章中设置超链接跳转到本地html文件"></a>文章中设置超链接跳转到本地html文件</h3><p>因为每次运行<code>hexo g</code>的时候，会自动将文件进行编译，会给文本添加格式与标签<br>如果想要设置自定义页面,首先将自定义的页面放入<code>/resource</code>文件下,这个文件下的所有文件最终会直接放到<code>public</code>静态文件夹中，想要引入里面的文件，直接引用路径即可。<br>为了避免html被编译，需要设置 跳过渲染 ,在配置文件<code>.config.yml</code>中进行配置。下面举个例子：</p>
<p><code>/resource</code> 文件目录下创建了一个 <code>work</code> 文件夹,此时需要引入 <code>work</code> 下面的 <code>index.html</code> 文件，需要在配置文件<code>.config.yml</code>中设置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">skip_render:</span></span><br><span class="line">    - <span class="string">'work/**'</span></span><br><span class="line"></span><br><span class="line">引入的时候只需要使用 `![](<span class="regexp">/work/</span>index.html)`</span><br></pre></td></tr></table></figure>
<h3 id="重新部署的问题"><a href="#重新部署的问题" class="headerlink" title="重新部署的问题"></a>重新部署的问题</h3><p>每次重新推送到gitee之后刷新页面都没有更新，但是在本地运行明明是OK的。最开始怎么也发现不了问题在哪里，最后脑壳都蒙圈了，发现竟然是gitee的pages服务需要手动刷新。。。。<br>这算是最我进的最大的坑了吧。。。<br><img src="/2020/04/04/hexo%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98/1.png" alt></p>
<h3 id="插入图片无法显示的问题"><a href="#插入图片无法显示的问题" class="headerlink" title="插入图片无法显示的问题"></a>插入图片无法显示的问题</h3><p>如何在文章中插入图片？</p>
<ul>
<li><p>先要将配置<code>_config.yml</code>里面的<code>post_asset_folder:false</code>这个选项设置为<code>true</code>。</p>
</li>
<li><p><code>npm install hexo-asset-image</code>,这样运行<code>hexo n &quot;xxx&quot;</code>来生成博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹，把图片放入该文件夹。（也可以手动创建同名文件夹）</p>
</li>
<li><p>再使用<code>![xxx](xxx/xxx.png)</code>引入图片</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">link</span> <span class="keyword">as</span>:<span class="comment">--&gt;/.com//1.png</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">link</span> <span class="keyword">as</span>:<span class="comment">--&gt;/.com//2.png</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">link</span> <span class="keyword">as</span>:<span class="comment">--&gt;/.com//3.png</span></span><br></pre></td></tr></table></figure>
<p>如果<code>hexo s</code>运行时出现上面代码，但是图片依旧不显示,是由于hexo3版本后对很多插件支持有问题<br>可直接安装已经修改过得插件<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code></p>
<p>注意每次都要使用 <code>hexo clean</code> 删除静态文件再重新运行奥~</p>
<p>感谢<br><a href="https://blog.csdn.net/sinat_42338962/article/details/94388760" target="_blank" rel="noopener">https://blog.csdn.net/sinat_42338962/article/details/94388760</a><br><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">https://www.jianshu.com/p/3db6a61d3782</a></p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>共享单车管理系统之框架之主页面架构设计</title>
    <url>/2020/04/05/%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>前一段时间跟着视频的学习一步一步完成了 共享单车管理系统 的开发，本次想要重新再回顾一遍，自己动手开始吧~</p>
<a id="more"></a> 

<h2 id="两种方式创建一个react应用"><a href="#两种方式创建一个react应用" class="headerlink" title="两种方式创建一个react应用"></a>两种方式创建一个react应用</h2><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">npm </span><span class="string">install </span><span class="built_in">create-react-app</span> -g</span><br><span class="line"><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">npx </span><span class="string">install </span><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br></pre></td></tr></table></figure>
<p>直接使用官方的脚手架吧~<br><code>npm start</code>运行</p>
<h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><h3 id="全局安装yarn"><a href="#全局安装yarn" class="headerlink" title="全局安装yarn"></a>全局安装yarn</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> yarn -g</span><br></pre></td></tr></table></figure>
<h3 id="安装react-router"><a href="#安装react-router" class="headerlink" title="安装react-router"></a>安装<code>react-router</code></h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> react-router-dom --save</span></span><br></pre></td></tr></table></figure>
<h3 id="安装AntD"><a href="#安装AntD" class="headerlink" title="安装AntD"></a>安装AntD</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">yarn add <span class="symbol">antd@</span><span class="number">3.4</span><span class="number">.3</span> --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="安装less-less-loader-因为ant-d是基于less开发的"><a href="#安装less-less-loader-因为ant-d是基于less开发的" class="headerlink" title="安装less less-loader 因为ant-d是基于less开发的"></a>安装less less-loader 因为ant-d是基于less开发的</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yarn add <span class="keyword">less</span> <span class="keyword">less</span>-loader --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="初始化git并且提交"><a href="#初始化git并且提交" class="headerlink" title="初始化git并且提交"></a>初始化git并且提交</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git <span class="keyword">add</span><span class="bash"> ./</span></span><br><span class="line">git commit -m <span class="string">'1 commit'</span></span><br></pre></td></tr></table></figure>
<h3 id="暴露webpack配置文件"><a href="#暴露webpack配置文件" class="headerlink" title="暴露webpack配置文件"></a>暴露webpack配置文件</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">yarn eject  <span class="regexp">//</span>执行之前必须先提交,否则会报以下错误</span><br><span class="line"></span><br><span class="line">Remove untracked files, stash or commit any changes, and try again.</span><br><span class="line">error Command failed with <span class="keyword">exit</span> code <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件，使用less-loader去解析less文件"><a href="#修改配置文件，使用less-loader去解析less文件" class="headerlink" title="修改配置文件，使用less-loader去解析less文件"></a>修改配置文件，使用<code>less-loader</code>去解析<code>less</code>文件</h3><p>  找到<code>config</code>文件下的<code>webpack.config.js</code>文件,找到并修改第48和110行<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// style files regexes</span></span><br><span class="line"><span class="keyword">const</span> cssRegex = <span class="regexp">/\.(css|less)$/</span>; <span class="comment">//修改第48行</span></span><br><span class="line"><span class="keyword">const</span> cssModuleRegex = <span class="regexp">/\.module\.css$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassRegex = <span class="regexp">/\.(scss|sass)$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassModuleRegex = <span class="regexp">/\.module\.(scss|sass)$/</span>;</span><br></pre></td></tr></table></figure><br>  <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds PostCSS Normalize as the reset css with default options,</span></span><br><span class="line">           <span class="comment">// so that it honors browserslist config in package.json</span></span><br><span class="line">           <span class="comment">// which in turn let's users customize the target behavior as per their needs.</span></span><br><span class="line">           <span class="selector-tag">postcssNormalize</span>(),</span><br><span class="line">         ],</span><br><span class="line">         <span class="selector-tag">sourceMap</span>: <span class="selector-tag">isEnvProduction</span> <span class="selector-tag">&amp;</span><span class="selector-tag">&amp;</span> <span class="selector-tag">shouldUseSourceMap</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attribute">loader</span>:require.resolve(<span class="string">'less-loader'</span>)    <span class="comment">//修改行</span></span><br><span class="line">     &#125;</span><br><span class="line">   ]<span class="selector-class">.filter</span>(Boolean);</span><br></pre></td></tr></table></figure><br>由于use数组的执行顺序是从后到前，故在最下方添加<code>less-loader</code>加载则会被最先执行。修改完文件内容后需要重启项目<code>yarn start</code>生效。</p>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>因为每次使用ant-d组件的时候，都要引入ant-d.css样式文件，但实际上我们并不需要所有组件的样式。<br>为了提高性能，我们希望只引入我们使用到的组件的样式，实现<strong>按需加载</strong></p>
<h3 id="安装-react-app-rewired-插件"><a href="#安装-react-app-rewired-插件" class="headerlink" title="安装 react-app-rewired 插件"></a>安装 react-app-rewired 插件</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> react-app-rewired customize-cra</span></span><br></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* package.json */</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">-   <span class="string">"start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line">+   <span class="string">"start"</span>: <span class="string">"react-app-rewired start"</span>,</span><br><span class="line">-   <span class="string">"build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line">+   <span class="string">"build"</span>: <span class="string">"react-app-rewired build"</span>,</span><br><span class="line">-   <span class="string">"test"</span>: <span class="string">"react-scripts test"</span>,</span><br><span class="line">+   <span class="string">"test"</span>: <span class="string">"react-app-rewired test"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在项目根目录创建一个 <code>config-overrides.js</code> 用于修改默认配置。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>.exports = function <span class="keyword">override</span>(<span class="built_in">config</span>, env) &#123;</span><br><span class="line">  <span class="comment">// do stuff with the webpack config...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">config</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>yarn start</code>命令运行之后报错：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Error: </span>Cannot find module 'react-scripts/package.json'</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong>：缺少react-scripts插件<br><strong>解决方案</strong>：安装 react-scripts 插件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save react-scripts</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>写给自己的话</title>
    <url>/2020/04/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>&emsp;&emsp;每天都是新的开始，做好准备，才能迎接更好的未来。</p>
<a id="more"></a> 

<h3 id="不安"><a href="#不安" class="headerlink" title="不安"></a>不安</h3><p>临近毕业，很多事情不断的涌进脑海。<br>毕设，工作，父母，建筑，学习……<br>仿佛人生到了一个转折点，不再是一个无忧无虑的时刻了。今后的日子应该如何，选择很重要。</p>
<h3 id="建筑-VS-前端"><a href="#建筑-VS-前端" class="headerlink" title="建筑 VS 前端"></a>建筑 VS 前端</h3><p>和朋友聊聊天，说到转行的不易，有多少份简历石沉大海，就有多少次怀疑直击内心。<br>要不要先找到一份建筑的工作让自己安下这颗不稳定的心，以及要不要放手一搏不留退路。</p>
<h3 id="我的选择"><a href="#我的选择" class="headerlink" title="我的选择"></a>我的选择</h3><p>我想要选择放手一搏，既然心是向往的，就不要给自己一个松懈的借口。身边有支持着你的人，如果就这样选择放弃了，回过头，好像都是些可笑的回忆。</p>
<h4 id="心之所及，就是远方"><a href="#心之所及，就是远方" class="headerlink" title="心之所及，就是远方"></a>心之所及，就是远方</h4><p>不抛弃，不放弃，好好做好每一件事，相信自己，就一定可以的！加油！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>使用hexo从零开始搭建博客</title>
    <url>/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>&emsp;&emsp;之前做了一个个人主页，但是由于部署在github，导致国内网打开很慢的原因，因此上网搜索了一些解决的办法。看到很多搭建博客的方法，索性不如也把自己的博客搭建起来，于是乎，特此写一篇笔记记录一下心得以及踩过的大部分坑吧~</p>
<a id="more"></a> 

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>打开<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>下载安装node.js<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/1.png" alt></p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>打开<a href="https://git-scm.com/download" target="_blank" rel="noopener">Git官网</a>,选择下载对应版本安装<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/2.png" alt></p>
<h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>由于npm的服务器位于国外可能影响安装，为了提高下载速度，我们来安装一个cnpm<br><code>npm install cnpm -g --registry=https://registry.npm.taobao.org</code></p>
<h3 id="全局安装hexo"><a href="#全局安装hexo" class="headerlink" title="全局安装hexo"></a>全局安装hexo</h3><p><code>cnpm install -g hexo</code></p>
<h2 id="搭建一个博客"><a href="#搭建一个博客" class="headerlink" title="搭建一个博客"></a>搭建一个博客</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>输入<code>hexo init</code>初始化项目<br>然后会出现这样一个目录<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/3.png" alt></p>
<h3 id="打包成静态文件"><a href="#打包成静态文件" class="headerlink" title="打包成静态文件"></a>打包成静态文件</h3><p>输入<code>hexo g</code>会将文件编译为静态文件，md格式会编译为html<br>此时文件中会多出一个<code>public</code>文件夹</p>
<h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p>输入<code>hexo s</code> 运行，在浏览器中输入 <code>http://localhost:4000</code><br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4.png" alt></p>
<h2 id="部署到码云"><a href="#部署到码云" class="headerlink" title="部署到码云"></a>部署到码云</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>进入<a href="https://gitee.com/" target="_blank" rel="noopener">码云官网</a>，登录账号，创建一个仓库，注意仓库路径必须是<code>&lt;user-name&gt;.github.io</code>,<code>&lt;user-name&gt;</code>是自己的用户名<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/5.png" alt><br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/6.png" alt></p>
<h3 id="连接仓库"><a href="#连接仓库" class="headerlink" title="连接仓库"></a>连接仓库</h3><p>点击仓库旁的 克隆下载，复制https地址<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7.png" alt><br>然后打开blog文件夹中的<code>_config.yml</code>文件（项目配置文件），搜索<code>deploy</code><br>将repo:后面的网址改成你复制的地址，保存。<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/8.png" alt></p>
<h3 id="推送到仓库"><a href="#推送到仓库" class="headerlink" title="推送到仓库"></a>推送到仓库</h3><p>安装<code>hexo-deployer-git</code>模块，gitbash 运行 <code>cnpm install hexo-deployer-git --save</code></p>
<p>安装好之后，文件夹会多出来一个.deploy_git,然后运行命令 <code>hexo g -d</code>,就可以把内容推送到码云了。</p>
<h3 id="开启码云Page服务"><a href="#开启码云Page服务" class="headerlink" title="开启码云Page服务"></a>开启码云Page服务</h3><p>点击仓库右上角的服务，然后点击Gitee Pages<br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/9.png" alt><br><img src="/2020/04/04/hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/10.png" alt><br>注意，以后每次提交至gitee后都要来手动更新哦~~也可以花钱购买自动部署服务</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
